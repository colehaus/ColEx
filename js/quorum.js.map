{"version":3,"sources":["webpack:////nix/store/673623s27gwd91gf6fbdyb977w4sak13-node-dependencies-ColEx-0.1.0/lib/node_modules/jStat/dist/jstat.js","webpack:///./libs/plot.wp.es.js","webpack:///./quorum.wp.es.js","webpack:////nix/store/673623s27gwd91gf6fbdyb977w4sak13-node-dependencies-ColEx-0.1.0/lib/node_modules/jquery-flot/jquery.flot.js","webpack:///./libs/colors.wp.es.js","webpack:///./libs/mcmc.wp.es.js"],"names":["factory","jStat","Math","undefined","concat","Array","prototype","slice","toString","Object","calcRdx","n","m","val","pow","log","LOG10E","isArray","arg","call","isFunction","isNumber","_init","arguments","retZero","retOne","retIdent","i","j","fn","args","map","length","this","seq","apply","toArray","constructor","utils","toVector","arr","extend","obj","rows","cols","dimensions","row","index","rowa","col","submat","arange","forEach","ind","column","cola","a","diag","nrow","res","antidiag","transpose","objArr","push","func","toAlter","ncol","cumreduce","alter","create","zeros","ones","rand","random","identity","symmetric","size","clear","min","max","cnt","hival","step","current","start","end","rl","_slice","list","copy","rcSlice","colSlice","rowSlice","sliceAssign","A","B","nl","ml","diagonal","diagArray","mat","t","jProto","sort","splice","funcs","passfunc","results","self","setTimeout","split","Function","ascNum","b","clip","sum","sumsqrd","sumsqerr","tmp","mean","sumrow","product","prod","low","high","unique","hash","_arr","meansqerr","geomean","median","arrlen","cumsum","cumprod","diff","diffs","arrLen","rank","sorted","ranks","first","indexOf","last","lastIndexOf","mode","count","maxCount","numMaxCount","mode_arr","range","variance","flag","pooledvariance","reduce","samples","deviation","dev","stdev","sqrt","pooledstdev","meandev","abs","meddev","coeffvar","quartiles","round","quantiles","quantilesArray","alphap","betap","p","aleph","k","gamma","sortedArray","quantileVals","floor","percentile","realIndex","parseInt","frac","percentileOfScore","score","kind","value","counter","len","strict","histogram","bins","binCnt","binWidth","covariance","arr1","arr2","u","v","arr1Len","sq_dev","corrcoeff","spearmancoeff","stanMoment","mu","sigma","skewSum","skewness","kurtosis","fullbool","tmpthis","callbackFunction","argsToPass","curriedFunction","vector","gammaln","x","xx","y","cof","ser","gammafn","z","yi","q","fact","xden","xnum","Infinity","PI","sin","gammap","lowRegGamma","an","aln","ap","del","c","d","h","ITMAX","NaN","exp","factorialln","factorial","combination","combinationln","permutation","betafn","betaln","betacf","m2","aa","qab","qap","qam","gammapinv","pp","lna1","afac","a1","gln","erf","ty","isneg","dd","erfc","erfcinv","err","ibetainv","lna","lnb","al","w","b1","ibeta","bt","randn","randg","shape","a2","oalph","tukeyWprob","rr","cc","xleg","aleg","qsqz","wincr","pr_w","normal","cdf","blb","binc","bub","einsum","cc1","wi","elsum","jj","ac","qexpo","rinsum","callee","_a","_b","_c","newthis","data","sample","vals","fnfunc","beta","pdf","alpha","inv","centralF","df1","df2","binomial","cauchy","local","scale","atan","tan","chisquare","dof","exponential","rate","invgamma","kumaraswamy","Error","lognormal","noncentralt","ncp","studentt","flip","prob","lastvalue","std","pareto","SQRT2","dof2","weibull","uniform","binomarr","negbin","r","hypgeom","N","scaledPDF","samplesDone","scaledCDF","factor","poisson","l","sumarr","L","triangular","arcsine","asin","cos","laplace","tukey","nmeans","df","xlegq","alegq","Number","isFinite","ulen","f2","f2lf","f21","ff4","ans","otsum","twa1","t1","x1","x0","ps","tukeyQinv","valx0","valx1","iter","isUsable","add","subtract","divide","multiply","nrescols","rescols","outer","dot","left","right","norm","nnorm","isNaN","angle","acos","aug","newarr","gauss_jordan","result","det","alen","alend","rowshift","colshift","mrow","mcol","gauss_elimination","maug","pivot","temp","maxrow","y2","triaUpSolve","parts","matrix_mode","triaLowSolve","lu","R","cholesky","T","gauss_jacobi","xv","xk","gauss_seidel","SOR","householder","QR","lstsq","array_mode","Q","attrs","Q1","RI","I","Aj","cAi","Ij","cIi","R_I","Q2","jacobi","maxim","theta","s","condition","e","ev","rungekutta","f","t_j","u_j","order","k1","k2","k3","romberg","h1","g","richardson","X","pos","y1","h_min","simpson","hermite","F","dF","dl","lagrange","cubic_spline","sq","gauss_quadrature","PCA","temp1","Bt","V","D","temp2","Y","C","Vt","differenceOfProportions","p1","n1","p2","n2","pooled","zscore","ztest","sides","tscore","ttest","anovafscore","expVar","sampMean","sampSampMean","tmpargs","unexpVar","anovaftest","ftest","fscore","anovaftes","qscore","mean1","mean2","sd","qtest","tukeyhsd","arrays","means","normalci","change","tci","significant","pvalue","oneSidedDifferenceOfProportions","twoSidedDifferenceOfProportions","models","ols","endog","exog","nobs","df_model","df_resid","coef","predict","resid","ybar","SSE","SSR","SST","R2","t_test","model","var_count","subModelList","endog_index","exog_index","filter","sigmaHat","seBetaHat","mod","tStatistic","pValue","leftppf","interval95","se","F_statistic","F_test","adjust_R2","module","exports","__WEBPACK_IMPORTED_MODULE_0_jStat__","__webpack_require__","__WEBPACK_IMPORTED_MODULE_0_jStat___default","histogramCounts","xs","breaks","ceil","twoDArrayCol","array","col_i","__webpack_exports__","sampleFunc","points","xHistLims","xss","yHistLims","yss","ys","getHeight","hist","__WEBPACK_IMPORTED_MODULE_5_libs_mcmc__","plotOptions","font","shadowSize","yaxis","tickLength","xaxis","legend","backgroundColor","color","__WEBPACK_IMPORTED_MODULE_3_libs_colors__","bodyText","grid","colors","chroma","interval","plotMcmcHist","jq","paramData","conf","preds","barData","plotOpts","__WEBPACK_IMPORTED_MODULE_1_jquery___default","logTrans","ticks","transform","inverseTransform","tickDecimals","lims","xlims","ylims","pred","label","width","__WEBPACK_IMPORTED_MODULE_4_libs_plot__","bars","show","align","barWidth","compValue","compPerc","comp","percLarger","__WEBPACK_IMPORTED_MODULE_2_jStat___default","percSmallerLarger","toPrecision","lines","lineWidth","di","intervAdd","nbrPoints","upper","lower","boundedI","HDI","plot","freq","ds","alert","cis","lb","ub","bound","ci","attr","getData","check","stringToNums","replace","parseFloat","dif","inputGraph","click","parent","hasClass","progress","html","run_BEST","chain","posterior_predictive_check","best","jQuery","$","make","o","charAt","normalize","join","clamp","clone","extract","elem","css","toLowerCase","nodeName","get","parse","str","exec","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","hasOwnProperty","Canvas","cls","container","element","children","document","createElement","className","direction","position","top","appendTo","getContext","window","G_vmlCanvasManager","initElement","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","height","textContainer","text","_textCache","Plot","placeholder","data_","options_","plugins","series","options","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundOpacity","tickColor","autoscaleMargin","tickFormatter","labelWidth","labelHeight","reserveSpace","alignTicksWithAxis","tickSize","minTickSize","xaxes","yaxes","radius","fill","fillColor","symbol","steps","horizontal","zero","highlightColor","aboveData","borderColor","labelMargin","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","hooks","surface","overlay","eventHolder","ctx","octx","plotOffset","bottom","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","drawBackground","drawSeries","draw","bindEvents","drawOverlay","shutdown","executeHooks","hook","setData","parseData","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","getOrCreateAxis","axisNumber","fillInSeriesOptions","format","topSentry","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","updateAxis","axis","datamin","datamax","each","allAxes","_","used","datapoints","number","required","autoscale","defaultValue","pointsize","insertSteps","nullify","xmin","ymin","xmax","ymax","delta","processData","coord","grep","canvasToAxisCoords","c2p","axes","redrawTimeout","clearTimeout","unbind","onMouseMove","onMouseLeave","onClick","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","innermost","outermost","found","box","setupGrid","showGrid","axisOpts","opts","widen","setRange","allocatedAxes","noTicks","dec","LN10","maxDec","magn","tickGenerator","prev","base","formatted","decimal","precision","substr","otherAxis","niceTicks","extraDec","ts","test","toFixed","setupTickGeneration","oticks","setTicks","snapRangeToTicks","maxWidth","legacyStyles","layer","info","getTextInfo","measureTickLabels","minMargin","margins","adjustLayoutForThingsStickingOut","allocateAxisBoxSecondPhase","it","p2c","setTransformationHelpers","tick","halign","valign","removeText","addText","find","remove","fragments","entries","rowStarted","lf","reverse","ascending","entry","table","div","prependTo","insertLegend","save","translate","fillStyle","getColorOrGradient","fillRect","restore","drawGrid","render","triggerRedrawOverlay","extractRange","ranges","from","to","key","bw","bc","getAxes","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","lineJoin","sw","getFillStyle","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","plotLineArea","drawSeriesLines","barLeft","fillStyleCallback","barRight","drawBar","plotBars","drawSeriesBars","plotPoints","offset","shadow","arc","closePath","drawSeriesPoints","drawLeft","drawRight","drawTop","drawBottom","filloptions","seriesColor","getPlaceholder","getCanvas","getPlotOffset","getXAxes","getYAxes","getOptions","highlight","unhighlight","pointOffset","point","destroy","removeData","empty","highlights","classes","init","initPlugins","axisOptions","axisCount","fontSize","fontSizeDefault","fontDefaults","style","variant","weight","family","lineHeight","x2axis","y2axis","coloredAreas","coloredAreasColor","parseOptions","existing","setupCanvases","mousemove","bind","triggerClickHoverEvent","eventname","event","seriesFilter","canvasX","pageX","canvasY","pageY","item","mouseX","mouseY","maxDistance","smallestDistance","mx","my","maxx","maxy","dx","dy","dist","datapoint","dataIndex","seriesIndex","findNearbyItem","auto","trigger","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","pointRadius","spec","defaultColor","gradient","createLinearGradient","co","brightness","opacity","addColorStop","detach","parentNode","removeChild","clearRect","cache","layerKey","getTextLayer","layerCache","styleKey","hide","styleCache","positions","active","rendered","append","font-size","insertAfter","addClass","textStyle","max-width","outerWidth","outerHeight","text-align","version","hue","bodyBackAlt","inactive","lightText","noteBack","menu","burn_timeout_id","sample_timeout_id","plot_timeout_id","__WEBPACK_IMPORTED_MODULE_1_libs_plot__","generalized_beta","normed","params","n_samples_","n_burnin","progress_cb","final_cb","burn_asynch","sampler","burn","n_samples_asynch","plot_asynch","running_asynch","fracDone","samples_left","start_values","posterior","n_params","batch_count","curr_state","log_sd","acceptance_count","next_sample","param_i","param_prop","prop","n_samples","nbr_of_samples","temp_chain","amwg","log_p","subj_i"],"mappings":"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","file":"quorum.js","sourcesContent":["(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.jStat = factory();\n    }\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(arg) {\n  return typeof arg === 'number' && arg === arg;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  var i;\n\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (var i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function(i) {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (var i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (var i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, Math.random);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var issymmetric = true;\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      var colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      var rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    var rowSlice = rcSlice.row || {};\n    var colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    var nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    var ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  var ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  var nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = new Function(\n        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  return Math.pow(jStat.product(arr), 1 / arr.length);\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (var i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var arrlen = arr.length;\n  var sorted = arr.slice().sort(ascNum);\n  var ranks = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    var first = sorted.indexOf(arr[i]);\n    var last = sorted.lastIndexOf(arr[i]);\n    if (first === last) {\n      var val = first;\n    } else {\n      var val = (first + last) / 2;\n    }\n    ranks[i] = val + 1;\n  }\n  return ranks;\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (var i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (var i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Returns the k-th percentile of values in a range, where k is in the\n// range 0..1, exclusive.\njStat.percentile = function percentile(arr, k) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length - 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n\n  if (index + 1 < _arr.length) {\n    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;\n  } else {\n    return _arr[index];\n  }\n}\n\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (var i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, bins) {\n  var first = jStat.min(arr);\n  var binCnt = bins || 4;\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (var i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (var i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (var i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        var callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        var callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res, sum, ysq;\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (var i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (var i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an, endval;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q, mat;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = Math.random();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function(a, b, c) {\n      if (!(this instanceof arguments.callee))\n        return new arguments.callee(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local, scale) {\n    return local;\n  },\n\n  mode: function mode(local, scale) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(rate) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(Math.random());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(alpha, beta) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu, sigma) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean, std) {\n    return mean;\n  },\n\n  median: function median(mean, std) {\n    return mean;\n  },\n\n  mode: function (mean, std) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale, shape) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(dof) {\n    return 0;\n  },\n\n  mode: function mode(dof) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var binomarr = [],\n    k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    if (x < n) {\n      for (; k <= x; k++) {\n        binomarr[ k ] = jStat.binomial.pdf(k, n, p);\n      }\n      return jStat.sum(binomarr);\n    }\n    return 1;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sample: function sample(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= Math.random();\n    } while (p > L);\n    return k - 1;\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = Math.random();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu, b) {\n    return mu;\n  },\n\n  median: function(mu, b) {\n    return mu;\n  },\n\n  mode: function(mu, b) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = Math.random() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    for (var i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (var i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    var alen = a.length,\n    alend = alen * 2,\n    vals = new Array(alend),\n    rowshift = alen - 1,\n    colshift = alend - 1,\n    mrow = rowshift - alen + 1,\n    mcol = colshift,\n    i = 0,\n    result = 0,\n    j;\n    // check for special 2x2 case\n    if (alen === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n    for (; i < alend; i++) {\n      vals[i] = 1;\n    }\n    for (var i = 0; i < alen; i++) {\n      for (j = 0; j < alen; j++) {\n        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];\n        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];\n        mrow++;\n        mcol--;\n      }\n      mrow = --rowshift - alen + 1;\n      mcol = --colshift;\n    }\n    for (var i = 0; i < alen; i++) {\n      result += vals[i];\n    }\n    for (; i < alend; i++) {\n      result -= vals[i];\n    }\n    return result;\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(var i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (var i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b),\n    h = m.length,\n    w = m[0].length;\n    var c = 0;\n    // find max pivot\n    for (var y = 0; y < h; y++) {\n      var maxrow = y;\n      for (var y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (var y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (var x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (var y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (var y2 = 0; y2 < y; y2++) {\n        for (var x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (var x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[i][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function get_Q1(x) {\n      var size = x.length;\n      var norm_x = jStat.norm(x, 2);\n      var e1 = jStat.zeros(1, size)[0];\n      e1[0] = 1;\n      var u = jStat.add(jStat.multiply(jStat.multiply(e1, norm_x), -1), x);\n      var norm_u = jStat.norm(u, 2);\n      var v = jStat.divide(u, norm_u);\n      var Q = jStat.subtract(jStat.identity(size),\n                             jStat.multiply(jStat.outer(v, v), 2));\n      return Q;\n    }\n\n    function qr(A) {\n      var size = A[0].length;\n      var QList = [];\n      jStat.arange(size).forEach(function(i) {\n        var x = jStat.slice(A, { row: { start: i }, col: i });\n        var Q = get_Q1(x);\n        var Qn = jStat.identity(A.length);\n        Qn = jStat.sliceAssign(Qn, { row: { start: i }, col: { start: i }}, Q);\n        A = jStat.multiply(Qn, A);\n        QList.push(Qn);\n      });\n      var Q = QList.reduce(function(x, y){ return jStat.multiply(x,y) });\n      var R = A;\n      return [Q, R];\n    }\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      x = jStat.copy(x);\n      r = jStat.zeros(p, p);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function(A, b) {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n\t  var Q2 = jStat.transpose(Q1);\n\n\t  if(Q2[0].length === undefined){\n\t\t  Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n\t  if(x.length === undefined){\n\t\t  x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var count = 0;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      count++;\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (var i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (var i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (var i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I, d;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var n = X.length,\n    h_min = Math.abs(x - X[pos(X, x) + 1]),\n    i = 0,\n    g = [],\n    h1 = [],\n    y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (var i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (var i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var flag = false;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (var i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (var i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (var i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (var i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // 2 sample case\n    if (args.length === 2) {\n      return jStat.variance(args[0]) / jStat.variance(args[1]);\n    }\n    // Builds sample array\n    sample = new Array();\n    for (var i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (var i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (var i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n\n  function sub_regress(endog, exog) {\n    return ols(endog, exog);\n  }\n\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /nix/store/673623s27gwd91gf6fbdyb977w4sak13-node-dependencies-ColEx-0.1.0/lib/node_modules/jStat/dist/jstat.js\n// module id = 6\n// module chunks = 0","/* eslint camelcase: \"off\" */\n\nimport jStat from 'jStat'\n\nvar yHistLims = function (yss) {\n  var ys = []\n  for (var i = 0, l = yss.length; i < l; i++) {\n    ys = ys.concat(twoDArrayCol(histogramCounts(yss[i]), 1))\n  }\n  return [\n    jStat.min(ys) * 0.8,\n    jStat.max(ys) * 1.2\n  ]\n}\nvar xHistLims = function (xss) {\n    // flatten xs_\n  var xs = [].concat.apply([], xss)\n  return [\n    jStat.min(xs),\n    jStat.max(xs)\n  ]\n}\nvar sampleFunc = function (min, max, func) {\n  var step = (max - min) / 200\n  var points = []\n  for (var i = min; i < max; i += step) {\n    points.push([i, func(i)])\n  }\n  points.push([max, func(max)])\n  return points\n}\nvar getHeight = function (x, hist) {\n  var i = 0\n  while (!(x > hist[i][0] && x < hist[i + 1][0])) {\n    i++\n  }\n  return hist[i][1]\n}\nvar histogramCounts = function (xs) {\n  var l = xs.length\n  var min = jStat.min(xs)\n  var max = jStat.max(xs)\n  var breaks = Math.ceil(Math.sqrt(l))\n  var step = (max - min) / breaks\n  if (max - min === 0) { return [[xs[0], l]] }\n  var bins = []\n  for (var i = 0; i < breaks; i++) {\n    bins.push([min + i * step + step / 2, 0])\n  }\n  for (i = 0; i < l; i++) {\n    var bin_i = xs[i] === max ? breaks - 1 : Math.floor((xs[i] - min) / step)\n    bins[bin_i][1]++\n  }\n  for (i = 0; i < breaks; i++) {\n    bins[i][1] = bins[i][1] / l / step\n  }\n  return bins\n}\nvar twoDArrayCol = function (array, col_i) {\n  var col = []\n  for (var i = 0, l = array.length; i < l; i++) {\n    col.push(array[i][col_i])\n  }\n  return col\n}\n\nexport default {\n  twoDArrayCol,\n  histogramCounts,\n  sampleFunc,\n  xHistLims,\n  yHistLims,\n  getHeight\n}\n\n\n\n// WEBPACK FOOTER //\n// ./libs/plot.wp.es.js","/* eslint no-undef: \"off\" */\n\nimport 'jquery-flot'\nimport $ from 'jquery'\nimport jStat from 'jStat'\n\nimport colors from 'libs/colors'\nimport plot from 'libs/plot'\nimport mcmc from 'libs/mcmc'\n\nconst plotOptions = {\n  font: {size: 8},\n  shadowSize: 0,\n  yaxis: {tickLength: 5},\n  xaxis: {tickLength: 5},\n  legend: {\n    backgroundColor: 'rgba(0, 0, 0, 0)',\n    color: colors.bodyText\n  },\n  grid: {\n    backgroundColor: null,\n    color: colors.bodyText\n  },\n  colors: colors.chroma.slice(1)\n}\nconst interval = [-1, 1]\n\nconst plotMcmcHist = (jq, paramData, conf, preds = []) => {\n  let barData\n  let plotOpts = $.extend(true, {}, plotOptions)\n  const data = []\n  if (conf.log === true) {\n    const logTrans = {\n      ticks: [0, 0.01, 0.1, 1, 10, 100],\n      transform: v => Math.log(v + 0.001),\n      inverseTransform: v => Math.exp(v),\n      tickDecimals: 2\n    }\n    $.extend(plotOpts.xaxis, logTrans)\n    $.extend(plotOpts.yaxis, logTrans)\n  }\n\n  const lims = ([min, max]) => {\n    if (conf.log === true) {\n      return {min: min / 2, max: max * 2}\n    } else {\n      return {min, max}\n    }\n  }\n  if (typeof conf.xlims === 'object' && conf.xlims !== null) {\n    $.extend(plotOpts.xaxis, lims(conf.xlims))\n  }\n  if (typeof conf.ylims === 'object' && conf.ylims !== null) {\n    $.extend(plotOpts.yaxis, lims(conf.ylims))\n  }\n\n  if (preds.length !== 0) {\n    preds.forEach(pred => {\n      data.push({\n        data: pred,\n        // chroma[0] with alpha\n        color: 'rgba(165, 170, 204, 0.7)'\n        // color: 'rgba(215, 214, 230, 0.5)'\n      })\n    })\n    data[0].label = 'Posterior Prediction'\n  }\n  if (paramData.length !== 0) {\n    barData = plot.histogramCounts(paramData)\n    const width = barData.length > 1 ? barData[1][0] - barData[0][0] : 0.05\n    data.push({\n      data: barData,\n      bars: {\n        show: true,\n        align: 'center',\n        barWidth: width\n      },\n      color: 1\n    })\n  }\n\n  const percSmallerLarger = (comp, data) => {\n    const percLarger = jStat.mean(jStat.map(data, x => x >= comp ? 1 : 0))\n    return [1 - percLarger, percLarger]\n  }\n  if (typeof conf.compValue === 'number') {\n    const compPerc = percSmallerLarger(conf.compValue, paramData)\n    data.push({\n      data: [[conf.compValue, 0], [conf.compValue, Infinity]],\n      label: '' + (compPerc[0] * 100).toPrecision(3) + '% < ' +\n        conf.compValue + ' < ' + (compPerc[1] * 100).toPrecision(3) + '%',\n      lines: {lineWidth: 2},\n      color: 2\n    })\n  }\n\n  const boundedI = (c, x) => {\n    x = x.sort((a, b) => a - b)\n    const nbrPoints = Math.floor(x.length * c)\n    const upper = [x[x.length - 1 - nbrPoints], interval[1]]\n    const lower = [interval[0], x[nbrPoints]]\n    return -upper[0] < lower[1] ? upper : lower\n  }\n  const HDI = (c, x) => {\n    x = x.sort((a, b) => a - b)\n    const nbrPoints = Math.floor(x.length * c)\n    let [min, max] = [jStat.min(x), jStat.max(x)]\n    let width\n    for (let i = 0, l = x.length - nbrPoints; i < l; i++) {\n      width = x[i + nbrPoints] - x[i]\n      if (width < max - min) {\n        [min, max] = [x[i], x[i + nbrPoints]]\n      }\n    }\n    return [min, max]\n  }\n  if (typeof conf.di !== 'undefined' && conf.di !== null) {\n    const intervAdd = (c, [min, max]) => {\n      data.push({\n        data: [\n          [min, plot.getHeight(min === interval[0] ? max : min, barData)],\n          [max, plot.getHeight(max === interval[1] ? min : max, barData)]\n        ],\n        label: c.toPrecision(2).slice(2) + '% ' + conf.di + ' (' +\n          min.toPrecision(3) + ', ' + max.toPrecision(3) + ')',\n        lines: { lineWidth: 5 },\n        color: 3\n      })\n    }\n    if (conf.di === 'BI') {\n      [0.95, 0.99].forEach(c => {\n        intervAdd(c, boundedI(c, paramData))\n      })\n    } else {\n      [0.95].forEach(c => {\n        intervAdd(c, HDI(c, paramData))\n      })\n    }\n  }\n  if (typeof paramData.length !== 'undefined' && paramData.length !== 0) {\n    const mean = jStat.mean(paramData)\n    data.push({data: [[mean, 0]],\n      label: 'Mean: ' + mean.toPrecision(3),\n      points: { show: true },\n      color: 4\n    })\n  }\n  return $.plot(jq, data, plotOpts)\n}\n\nconst best = ds => {\n  const showResult = chain => {\n    inputGraph(mcmc.posterior_predictive_check(chain))\n    progress(0.925)\n\n    $('#stat-out').show()\n    plotMcmcHist($('#mean > div'),\n                 plot.twoDArrayCol(chain, 2),\n                 {di: 'BI', comp: 0, xlims: [-1, 1]}\n                )\n    progress(0.95)\n\n    const a = plot.twoDArrayCol(chain, 0)\n    const b = plot.twoDArrayCol(chain, 1)\n    const xlims = plot.xHistLims([a, b])\n    const ylims = plot.yHistLims([a, b])\n    plotMcmcHist($('#alpha > div'), a, { di: 'HDI', xlims, ylims, log: true })\n    progress(0.975)\n    plotMcmcHist($('#beta > div'), b, { di: 'HDI', xlims, ylims, log: true })\n    progress(1)\n  }\n  const progress = x => {\n    $('progress').attr('value', x)\n  }\n\n  $('.analyze').html('Re-analyze')\n  mcmc.run_BEST(ds, 20000, 20000, progress, showResult)\n}\n\nconst freq = ds => {\n  const l = ds.length\n  const dof = l - 1\n  if (l < 30) {\n    alert('We need at least 30 votes for this calculation. You need at least ' + (30 - l) + ' more.')\n    return\n  }\n\n  const mean = jStat.mean(ds)\n  const stdev = jStat.stdev(ds)\n  const cis = plot.sampleFunc(-1, 1, mu =>\n    jStat.studentt.pdf((mean - mu) / stdev * Math.sqrt(l), dof)\n  )\n  const ci = conf => {\n    const bound = jStat.studentt.inv(conf, dof) * stdev / Math.sqrt(l)\n    const y = jStat.studentt.pdf(jStat.studentt.inv(conf, dof), dof)\n    if (mean > 0) {\n      return [y, mean - bound, Infinity]\n    } else {\n      return [y, -Infinity, mean + bound]\n    }\n  }\n  const data = [{\n    data: cis,\n    lines: {show: true},\n    color: 1\n  }, {\n    data: [[mean, 0]],\n    label: 'Mean: ' + mean.toPrecision(3),\n    points: {show: true},\n    color: 4\n  }];\n  [0.95, 0.99].forEach(conf => {\n    const [y, lb, ub] = ci(conf)\n    data.push({\n      data: [[lb, y], [ub, y]],\n      label: conf.toPrecision(2).slice(2) + '% CI (' +\n        lb.toPrecision(3) + ', ' + ub.toPrecision(3) + ')',\n      lines: {lineWidth: 5},\n      color: 3\n    })\n  })\n  $('#stat-out').show()\n  $.plot($('#freq > div'), data, plotOptions)\n  $('progress').attr('value', 1)\n}\n\nconst getData = check => {\n  const stringToNums = s => {\n    s = s.replace(/[^-1234567890.]+$/, '').replace(/^[^-1234567890.]+/, '')\n    return jStat.map(s.split(/[^-1234567890.]+/), x => {\n      const f = parseFloat(x)\n      if (isNaN(f)) {\n        throw Error('NaN')\n      }\n      // If we let in 0 or 1, we end up taking log(0) later\n      const eps = 0.001\n      if (f <= 0) {\n        return eps\n      }\n      if (f >= 1) {\n        return 1 - eps\n      }\n      return f\n    })\n  }\n  let y1, y2\n  try {\n    y1 = stringToNums($('#data1').val())\n    y2 = stringToNums($('#data2').val())\n  } catch (err) {\n    alert('ERROR: Data not supplied for both groups or not formatted correctly.')\n    return null\n  }\n  const dif = y2.length - y1.length\n  if (dif !== 0 && check === true) {\n    const err = \" Since we're supposed to pair data, that's bad.\"\n    if (dif > 0) {\n      alert('You have ' + dif + ' more data points for Proposal 2 than for Proposal 1.' + err)\n      return null\n    } else {\n      alert('You have ' + -dif + ' more data points for Proposal 1 than for Proposal 2.' + err)\n      return null\n    }\n  }\n  const ds = []\n  const l = Math.min(y1.length, y2.length)\n  for (let i = 0; i < l; i++) {\n    ds.push(y2[i] - y1[i])\n  }\n  return [y1, y2, ds]\n}\n\nconst inputGraph = pred => {\n  const ys = getData()\n  if (typeof ys === 'undefined') { return }\n  const ylims = plot.yHistLims(ys)\n  plotMcmcHist($('#preview1 > div'), ys[0], {xlims: [0, 1], ylims})\n  plotMcmcHist($('#preview2 > div'), ys[1], {xlims: [0, 1], ylims})\n  plotMcmcHist($('#diff > div'), ys[2], {xlims: [-1, 1]}, pred)\n}\n\n$(() => {\n  $('.act > .analyze').click(() => {\n    const d = getData(true)\n    if (typeof d === 'undefined') { return }\n    if ($('#best').parent().hasClass('open')) {\n      best(d[2])\n    } else {\n      freq(d[2])\n    }\n  })\n  $('.preview').click(() => { inputGraph() })\n\n// For reasons unkown, setTimeout is required\n  setTimeout(function () { inputGraph() })\n  const plotOpts = {\n    grid: { show: false },\n    colors: [colors.value[3]]\n  }\n  $.plot($('#non-norm'),\n    [{\n      bars: { show: true },\n      data: [[-2, 4], [-1, 1], [0, 0], [1, 1], [2, 4]]\n    }], plotOpts)\n  $.plot($('#sym1'),\n    [{\n      bars: { show: true },\n      data: [[-2, 1], [-1, 0], [0, 0], [1, 2], [2, 0]]\n    }], plotOpts)\n  $.plot($('#sym2'),\n    [{ bars: { show: true },\n      data: [[-2, 0], [-1, 0], [0, 3], [1, 0], [2, 0]]\n    }], plotOpts)\n})\n\n\n\n// WEBPACK FOOTER //\n// ./quorum.wp.es.js","/*** IMPORTS FROM imports-loader ***/\nvar $ = require(\"jquery\");\nvar jQuery = require(\"jquery\");\n\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n\t\t\tinfo = styleCache[text] = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\telement: element,\n\t\t\t\tpositions: []\n\t\t\t};\n\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function(){\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            \n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very \n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be \n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /nix/store/673623s27gwd91gf6fbdyb977w4sak13-node-dependencies-ColEx-0.1.0/lib/node_modules/jquery-flot/jquery.flot.js\n// module id = 15\n// module chunks = 0","let colors = {\n  hue: [\n    '#b5bae6',\n    '#d1abe6',\n    '#e6abd0',\n    '#e6bcb5',\n    '#dee2b5',\n    '#b5e2b5',\n    '#b5e2df'\n  ],\n  chroma: [\n    '#d7d6e6',\n    '#b5bbe6',\n    '#919fe6',\n    '#6d84e6',\n    '#4769e6',\n    '#1d4de6'\n  ],\n  value: [\n    '#b5bbe6',\n    '#9090b8',\n    '#6b6688',\n    '#443c56',\n    '#18121e'\n  ]\n}\n\ncolors.bodyBack = '#eee'\ncolors.bodyBackAlt = colors.value[0]\ncolors.inactive = colors.value[2]\ncolors.lightText = colors.value[3]\ncolors.bodyText = colors.value[4]\n\ncolors.noteBack = colors.hue[4]\ncolors.menu = colors.hue[5]\n\nexport default colors\n\n\n\n// WEBPACK FOOTER //\n// ./libs/colors.wp.es.js","/* eslint camelcase: \"off\" */\n\nimport jStat from 'jStat'\nimport plot from 'libs/plot'\n\nvar interval = [-1, 1]\nvar burn_timeout_id\nvar sample_timeout_id\nvar plot_timeout_id\n\nvar posterior_predictive_check = function (chain) {\n  var rand_int = function (min, max) {\n    return Math.floor(Math.random() * (max - min)) + min\n  }\n\n  var n_post = 10\n  var l = chain.length\n  var preds = []\n  for (var i = 0; i < n_post; i++) {\n    var params = chain[rand_int(0, l)]\n    preds.push(plot.sampleFunc(-1, 1, function (x) {\n      return generalized_beta(x, params[0], params[1], interval)\n    }))\n  }\n  return preds\n}\nvar generalized_beta = function (x, a, b, interval) {\n  var min = interval[0]\n  var max = interval[1]\n  var normed = (x - min) / (max - min)\n  return jStat.beta.pdf(normed, a, b)\n}\nvar run_BEST = function (ys, n_samples_, n_burnin, progress_cb, final_cb) {\n    // Adaptive metropolis within Gibbs\n  var amwg = function (start_values, posterior) {\n    var n_params = start_values.length\n    var batch_count = 0\n    var batch_size = 50\n    var chain = []\n    var curr_state = start_values\n    var log_sd = []\n    var acceptance_count = []\n    for (var i = 0; i < n_params; i++) {\n      log_sd[i] = 0\n      acceptance_count[i] = 0\n    }\n\n    var burn = function (n) {\n      var temp_chain = chain.slice()\n      n_samples(n)\n      chain = temp_chain\n    }\n    var derived_params = function (p) {\n            // mean scaled to our interval\n      return interval[0] + jStat.beta.mean(p[0], p[1]) * (interval[1] - interval[0])\n    }\n    var next_sample = function () {\n      chain.push(curr_state.concat(derived_params(curr_state)))\n\n      for (var param_i = 0; param_i < n_params; param_i++) {\n        var param_prop = jStat.normal.sample(curr_state[param_i], Math.exp(log_sd[param_i]))\n        var prop = curr_state.slice()\n        prop[param_i] = param_prop\n        var accept_prob = Math.exp(posterior(prop) - posterior(curr_state))\n        if (accept_prob > Math.random()) {\n          acceptance_count[param_i]++\n          curr_state = prop\n        }\n      }\n\n      if (chain.length % batch_size === 0) {\n        batch_count++\n        for (param_i = 0; param_i < n_params; param_i++) {\n          if (acceptance_count[param_i] / batch_size > 0.44) {\n            log_sd[param_i] += Math.min(0.01, 1 / Math.sqrt(batch_count))\n          } else if (acceptance_count[param_i] / batch_size < 0.44) {\n            log_sd[param_i] -= Math.min(0.01, 1 / Math.sqrt(batch_count))\n          }\n          acceptance_count[param_i] = 0\n        }\n      }\n      return curr_state\n    }\n    var n_samples = function (n) {\n      for (var i = 0; i < n - 1; i++) {\n        next_sample()\n      }\n      return next_sample()\n    }\n    var running_asynch = false\n    var samples_left = n_samples_\n    var n_samples_asynch = function (n, nbr_of_samples) {\n      samples_left = n\n      if (n > 0) {\n        running_asynch = true\n        n_samples(nbr_of_samples)\n        return setTimeout(function () { n_samples_asynch(n - nbr_of_samples, nbr_of_samples) }, 0)\n      } else {\n        running_asynch = false\n        return null\n      }\n    }\n    return {\n      chain: function () { return chain },\n      running_asynch: function () { return running_asynch },\n      burn: burn,\n      n_samples: n_samples,\n      samples_left: function () { return samples_left },\n      n_samples_asynch: n_samples_asynch\n    }\n  }\n\n  var make_BEST_posterior_func = function (data) {\n    return function (params) {\n      var alpha = params[0]\n      var beta = params[1]\n      var log_p = 0\n      log_p += Math.log(jStat.exponential.pdf(alpha, 1))\n      log_p += Math.log(jStat.exponential.pdf(beta, 1))\n      for (var subj_i = 0, l = data.length; subj_i < l; subj_i++) {\n        log_p += Math.log(generalized_beta(data[subj_i], alpha, beta, interval))\n      }\n      return log_p\n    }\n  }\n\n  var burn_asynch = function (n) {\n    sampler.burn(500)\n    if (n > 0) {\n      var fracDone = 1 - 500 * n / n_burnin\n      progress_cb(0.45 * fracDone)\n      burn_timeout_id = setTimeout(function () { burn_asynch(n - 1) }, 0)\n    } else {\n      sample_timeout_id = sampler.n_samples_asynch(n_samples_, 50)\n      plot_asynch()\n    }\n  }\n  var plot_asynch = function () {\n    if (sampler.running_asynch()) {\n      var fracDone = 1 - sampler.samples_left() / n_samples_\n      progress_cb(0.45 + fracDone * 0.45)\n      plot_timeout_id = setTimeout(plot_asynch, 0)\n    } else {\n      final_cb(sampler.chain())\n    }\n  }\n\n  clearTimeout(burn_timeout_id)\n  clearTimeout(sample_timeout_id)\n  clearTimeout(plot_timeout_id)\n\n  var sampler = amwg([1, 1], make_BEST_posterior_func(ys))\n  burn_asynch(Math.ceil(n_burnin / 500))\n}\n\nexport default {\n  posterior_predictive_check: posterior_predictive_check,\n  run_BEST: run_BEST\n}\n\n\n\n// WEBPACK FOOTER //\n// ./libs/mcmc.wp.es.js"],"sourceRoot":""}