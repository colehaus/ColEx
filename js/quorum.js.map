{"version":3,"sources":["webpack:///./js/plot.wp.es.js","webpack:///./js/quorum.wp.es.js","webpack:////nix/store/0cfiqvxmcpndhw8zx0yc286xz1zc0bjx-node-dependencies-ColEx-0.1.0/lib/node_modules/jquery-flot/jquery.flot.js","webpack:///./js/colors.wp.es.js","webpack:///./js/mcmc.wp.es.js","webpack:////nix/store/0cfiqvxmcpndhw8zx0yc286xz1zc0bjx-node-dependencies-ColEx-0.1.0/lib/node_modules/jStat/dist/jstat.js"],"names":["_jStat","__webpack_require__","histogramCounts","xs","l","length","min","_jStat2","default","max","breaks","Math","ceil","sqrt","step","bins","i","push","floor","twoDArrayCol","array","col_i","col","sampleFunc","func","points","xHistLims","xss","concat","apply","yHistLims","yss","ys","getHeight","x","hist","plotOptions","font","size","shadowSize","yaxis","tickLength","xaxis","legend","backgroundColor","color","_colors2","bodyText","grid","colors","chroma","slice","interval","plotMcmcHist","jq","paramData","conf","preds","arguments","undefined","barData","plotOpts","_jquery2","extend","data","log","logTrans","ticks","transform","v","inverseTransform","exp","tickDecimals","lims","_ref","_ref2","_slicedToArray","_typeof","xlims","ylims","forEach","pred","label","width","_plot2","bars","show","align","barWidth","compValue","compPerc","comp","percLarger","mean","map","percSmallerLarger","Infinity","toPrecision","lines","lineWidth","di","intervAdd","c","_ref5","_ref6","sort","a","b","nbrPoints","upper","lower","boundedI","_ref3","_ref4","HDI","plot","freq","ds","dof","alert","stdev","mu","studentt","pdf","_ci","bound","inv","y","ci","_ci2","lb","ub","attr","getData","check","stringToNums","s","replace","split","f","parseFloat","isNaN","y1","y2","val","err","dif","inputGraph","click","progress","d","closest","hasClass","html","_mcmc2","run_BEST","chain","posterior_predictive_check","setTimeout","value","jQuery","$","make","r","g","o","add","charAt","normalize","scale","toString","join","clamp","parseInt","clone","extract","elem","css","toLowerCase","parent","nodeName","get","parse","str","res","m","exec","name","trim","lookupColors","aqua","azure","beige","black","blue","brown","cyan","darkblue","darkcyan","darkgrey","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkviolet","fuchsia","gold","green","indigo","khaki","lightblue","lightcyan","lightgreen","lightgrey","lightpink","lightyellow","lime","magenta","maroon","navy","olive","orange","pink","purple","violet","red","silver","white","yellow","hasOwnProperty","Object","prototype","Canvas","cls","container","element","children","document","createElement","className","direction","position","left","top","appendTo","getContext","window","G_vmlCanvasManager","Error","initElement","this","context","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","pixelRatio","resize","height","textContainer","text","_textCache","Plot","placeholder","data_","options_","plugins","series","options","noColumns","labelFormatter","labelBoxBorderColor","margin","backgroundOpacity","sorted","mode","tickColor","autoscaleMargin","tickFormatter","labelWidth","labelHeight","reserveSpace","alignTicksWithAxis","tickSize","minTickSize","xaxes","yaxes","radius","fill","fillColor","symbol","steps","horizontal","zero","highlightColor","aboveData","borderColor","labelMargin","axisMargin","borderWidth","minBorderMargin","markings","markingsColor","markingsLineWidth","clickable","hoverable","autoHighlight","mouseActiveRadius","interaction","redrawOverlayInterval","hooks","surface","overlay","eventHolder","ctx","octx","plotOffset","right","bottom","plotWidth","plotHeight","processOptions","processRawData","processDatapoints","processOffset","drawBackground","drawSeries","draw","bindEvents","drawOverlay","shutdown","executeHooks","hook","args","setData","parseData","neededColors","maxIndex","sc","colorPool","colorPoolSize","variation","colori","getOrCreateAxis","axisNumber","fillInSeriesOptions","j","k","ps","p","format","topSentry","Number","POSITIVE_INFINITY","bottomSentry","NEGATIVE_INFINITY","fakeInfinity","MAX_VALUE","updateAxis","axis","datamin","datamax","each","allAxes","_","used","datapoints","number","required","autoscale","defaultValue","pointsize","insertSteps","nullify","xmin","ymin","xmax","ymax","delta","processData","obj","coord","n","grep","canvasToAxisCoords","pos","c2p","x1","axes","redrawTimeout","clearTimeout","unbind","onMouseMove","onMouseLeave","onClick","allocateAxisBoxFirstPhase","lw","lh","isXAxis","padding","innermost","outermost","first","found","box","setupGrid","showGrid","axisOpts","opts","widen","setRange","allocatedAxes","noTicks","dec","LN10","maxDec","magn","pow","norm","tickGenerator","prev","base","start","NaN","factor","formatted","round","decimal","indexOf","precision","substr","isFunction","otherAxis","niceTicks","extraDec","ts","test","toFixed","setupTickGeneration","oticks","t","setTicks","snapRangeToTicks","maxWidth","legacyStyles","layer","info","getTextInfo","measureTickLabels","minMargin","margins","adjustLayoutForThingsStickingOut","allocateAxisBoxSecondPhase","identity","it","abs","p2c","setTransformationHelpers","tick","halign","valign","removeText","addText","find","remove","fragments","entries","rowStarted","lf","reverse","ascending","entry","table","div","prependTo","insertLegend","clear","save","translate","fillStyle","getColorOrGradient","fillRect","restore","drawGrid","render","triggerRedrawOverlay","extractRange","ranges","from","to","key","tmp","bw","bc","getAxes","xrange","yrange","xequal","yequal","subPixel","beginPath","strokeStyle","moveTo","lineTo","stroke","xoff","yoff","strokeRect","plotLine","xoffset","yoffset","axisx","axisy","prevx","prevy","x2","lineJoin","sw","angle","PI","sin","cos","getFillStyle","areaOpen","ypos","segmentStart","segmentEnd","x1old","x2old","plotLineArea","drawSeriesLines","barLeft","fillStyleCallback","barRight","drawBar","plotBars","drawSeriesBars","plotPoints","offset","shadow","arc","closePath","w","drawSeriesPoints","drawLeft","drawRight","drawTop","drawBottom","filloptions","seriesColor","getPlaceholder","getCanvas","getPlotOffset","getXAxes","getYAxes","getOptions","highlight","unhighlight","pointOffset","point","destroy","removeData","empty","highlights","classes","init","initPlugins","axisOptions","axisCount","fontSize","fontSizeDefault","fontDefaults","style","variant","weight","family","lineHeight","x2axis","y2axis","coloredAreas","coloredAreasColor","parseOptions","filter","existing","setupCanvases","mousemove","bind","e","triggerClickHoverEvent","eventname","event","seriesFilter","canvasX","pageX","canvasY","pageY","item","mouseX","mouseY","maxDistance","smallestDistance","mx","my","maxx","maxy","dx","dy","dist","datapoint","dataIndex","seriesIndex","findNearbyItem","h","auto","trigger","hi","drawBarHighlight","drawPointHighlight","indexOfHighlight","splice","pointRadius","spec","defaultColor","gradient","createLinearGradient","co","brightness","opacity","addColorStop","fn","detach","parentNode","removeChild","clearRect","cache","layerKey","call","getTextLayer","layerCache","styleKey","hide","styleCache","positions","active","rendered","append","font-size","insertAfter","addClass","textStyle","max-width","outerWidth","outerHeight","text-align","version","hue","bodyBackAlt","inactive","lightText","noteBack","menu","burn_timeout_id","sample_timeout_id","plot_timeout_id","generalized_beta","normed","beta","params","random","n_samples_","n_burnin","progress_cb","final_cb","plot_asynch","sampler","running_asynch","fracDone","samples_left","start_values","posterior","n_params","batch_count","curr_state","log_sd","acceptance_count","next_sample","param_i","param_prop","normal","sample","prop","n_samples","burn","temp_chain","n_samples_asynch","nbr_of_samples","amwg","alpha","log_p","exponential","subj_i","burn_asynch","factory","jStat","Array","calcRdx","LOG10E","isArray","arg","isNumber","_init","retZero","retOne","retIdent","seq","toArray","constructor","utils","toVector","arr","rows","cols","dimensions","row","index","rowa","submat","arange","ind","column","cola","diag","nrow","antidiag","transpose","objArr","toAlter","ncol","cumreduce","alter","create","zeros","ones","rand","symmetric","cnt","hival","current","end","rl","_slice","list","copy","rcSlice","colSlice","rowSlice","sliceAssign","A","B","nl","ml","diagonal","diagArray","mat","jProto","funcs","passfunc","results","self","Function","ascNum","clip","sum","sumsqrd","sumsqerr","sumrow","product","prod","low","high","unique","hash","_arr","meansqerr","geomean","median","arrlen","cumsum","cumprod","diff","diffs","arrLen","rank","ranks","last","lastIndexOf","count","maxCount","numMaxCount","mode_arr","range","variance","flag","pooledvariance","reduce","samples","deviation","dev","pooledstdev","meandev","meddev","coeffvar","quartiles","quantiles","quantilesArray","alphap","betap","aleph","gamma","sortedArray","quantileVals","percentile","realIndex","frac","percentileOfScore","score","kind","counter","len","strict","histogram","binCnt","binWidth","covariance","arr1","arr2","u","arr1Len","sq_dev","corrcoeff","spearmancoeff","stanMoment","sigma","skewSum","skewness","kurtosis","fullbool","tmpthis","callbackFunction","argsToPass","curriedFunction","vector","gammaln","xx","cof","ser","gammafn","z","yi","q","fact","xden","xnum","gammap","lowRegGamma","an","aln","ap","del","ITMAX","factorialln","factorial","combination","combinationln","permutation","betafn","betaln","betacf","m2","aa","qab","qap","qam","gammapinv","pp","lna1","afac","a1","gln","erf","ty","isneg","dd","erfc","erfcinv","ibetainv","lna","lnb","al","b1","ibeta","bt","randn","randg","shape","a2","oalph","tukeyWprob","rr","cc","xleg","aleg","qsqz","wincr","pr_w","cdf","blb","binc","bub","einsum","cc1","wi","elsum","jj","ac","qexpo","rinsum","callee","_a","_b","_c","newthis","vals","fnfunc","centralF","df1","df2","binomial","cauchy","local","atan","tan","chisquare","rate","invgamma","kumaraswamy","lognormal","noncentralt","ncp","flip","prob","lastvalue","std","pareto","SQRT2","dof2","weibull","uniform","binomarr","negbin","hypgeom","N","scaledPDF","samplesDone","scaledCDF","poisson","sumarr","L","triangular","arcsine","asin","laplace","tukey","nmeans","df","xlegq","alegq","isFinite","ulen","f2","f2lf","f21","ff4","ans","otsum","twa1","t1","x0","tukeyQinv","valx0","valx1","iter","isUsable","subtract","divide","multiply","nrescols","rescols","outer","dot","nnorm","acos","aug","newarr","gauss_jordan","result","det","alen","alend","rowshift","colshift","mrow","mcol","gauss_elimination","maug","pivot","temp","maxrow","triaUpSolve","parts","matrix_mode","triaLowSolve","lu","R","cholesky","T","gauss_jacobi","xv","xk","gauss_seidel","SOR","householder","QR","lstsq","array_mode","Q","attrs","Q1","RI","I","Aj","cAi","Ij","cIi","R_I","Q2","jacobi","maxim","theta","condition","ev","rungekutta","t_j","u_j","order","k1","k2","k3","romberg","h1","richardson","X","h_min","simpson","hermite","F","dF","dl","lagrange","cubic_spline","sq","gauss_quadrature","PCA","temp1","Bt","V","D","temp2","Y","C","Vt","differenceOfProportions","p1","n1","p2","n2","pooled","zscore","ztest","sides","tscore","ttest","anovafscore","expVar","sampMean","sampSampMean","tmpargs","unexpVar","anovaftest","ftest","fscore","anovaftes","qscore","mean1","mean2","sd","qtest","tukeyhsd","arrays","means","normalci","change","tci","significant","pvalue","oneSidedDifferenceOfProportions","twoSidedDifferenceOfProportions","models","ols","endog","exog","nobs","df_model","df_resid","coef","predict","resid","ybar","SSE","SSR","SST","R2","t_test","model","var_count","subModelList","endog_index","exog_index","sigmaHat","seBetaHat","mod","tStatistic","pValue","leftppf","interval95","se","F_statistic","F_test","adjust_R2","module","exports"],"mappings":"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","file":"quorum.js","sourcesContent":["import jStat from 'jStat'\n\nvar yHistLims = function(yss) {\n    var ys = [];\n    for (var i = 0, l = yss.length; i < l; i++) {\n        ys = ys.concat(twoDArrayCol(histogramCounts(yss[i]), 1));\n    }\n    return [\n        jStat.min(ys) * 0.8,\n        jStat.max(ys) * 1.2\n    ];\n};\nvar xHistLims = function(xss) {\n    //flatten xs_\n    var xs = [].concat.apply([], xss);\n    return [\n        jStat.min(xs),\n        jStat.max(xs)\n    ];\n};\nvar sampleFunc = function (min, max, func) {\n    var step = (max - min) / 200;\n    var points = [];\n    for (var i = min; i < max; i += step) {\n        points.push([i, func(i)]);\n    }\n    points.push([max, func(max)]);\n    return points;\n};\nvar getHeight = function(x, hist) {\n    var i = 0;\n    while (!(x > hist[i][0] && x < hist[i+1][0])) {\n        i++;\n    }\n    return hist[i][1];\n};\nvar histogramCounts = function (xs) {\n    var l = xs.length;\n    var min = jStat.min(xs);\n    var max = jStat.max(xs);\n    var breaks = Math.ceil(Math.sqrt(l));\n    var step = (max - min) / breaks;\n    if (max - min === 0) { return [[xs[0], l]]; }\n    var bins = [];\n    for (var i = 0; i < breaks; i++) {\n        bins.push([min + i * step + step / 2, 0]);\n    }\n    for (i = 0; i < l; i++) {\n        var bin_i = xs[i] === max ? breaks - 1 : Math.floor((xs[i] - min) / step);\n        bins[bin_i][1]++;\n    }\n    for (i = 0; i < breaks; i++) {\n        bins[i][1] = bins[i][1] / l / step;\n    }\n    return bins;\n};\nvar twoDArrayCol = function (array, col_i) {\n    var col = [];\n    for (var i = 0, l = array.length; i < l; i++) {\n        col.push(array[i][col_i]);\n    }\n    return col;\n};\n\nexport default {\n    twoDArrayCol: twoDArrayCol,\n    histogramCounts: histogramCounts,\n    sampleFunc: sampleFunc,\n    xHistLims: xHistLims,\n    yHistLims: yHistLims,\n    getHeight: getHeight\n};\n\n\n\n// WEBPACK FOOTER //\n// ./js/plot.wp.es.js","import 'jquery-flot'\nimport $ from 'jquery'\nimport jStat from 'jStat'\n\nimport colors from 'colors'\nimport plot from 'plot'\nimport mcmc from 'mcmc'\n\nconst plotOptions = {\n  font: {size: 8},\n  shadowSize: 0,\n  yaxis: {tickLength: 5},\n  xaxis: {tickLength: 5},\n  legend: {\n    backgroundColor: 'rgba(0, 0, 0, 0)',\n    color: colors.bodyText\n  },\n  grid: {\n    backgroundColor: null,\n    color: colors.bodyText\n  },\n  colors: colors.chroma.slice(1)\n};\nconst interval = [-1, 1];\n\nconst plotMcmcHist = (jq, paramData, conf, preds = []) => {\n  let barData;\n  let plotOpts = $.extend(true, {}, plotOptions);\n  const data = [];\n  if (conf.log === true) {\n    const logTrans = {\n      ticks: [0, 0.01, 0.1, 1, 10, 100],\n      transform: v => Math.log(v + 0.001),\n      inverseTransform: v => Math.exp(v),\n      tickDecimals: 2\n    };\n    $.extend(plotOpts.xaxis, logTrans);\n    $.extend(plotOpts.yaxis, logTrans);\n  }\n\n  const lims = ([min, max]) => {\n    if (conf.log === true) {\n      return {min: min / 2, max: max * 2};\n    } else {\n      return {min, max};\n    }\n  };\n  if (typeof conf.xlims === 'object' && conf.xlims !== null) {\n    $.extend(plotOpts.xaxis, lims(conf.xlims));\n  }\n  if (typeof conf.ylims === 'object' && conf.ylims !== null) {\n    $.extend(plotOpts.yaxis, lims(conf.ylims));\n  }\n\n  if (preds.length !== 0) {\n    preds.forEach(pred => {\n      data.push({\n        data: pred,\n        // chroma[0] with alpha\n        color: 'rgba(165, 170, 204, 0.7)'\n        // color: 'rgba(215, 214, 230, 0.5)'\n      });\n    });\n    data[0].label = 'Posterior Prediction';\n  }\n  if (paramData.length !== 0) {\n    barData = plot.histogramCounts(paramData);\n    const width = barData.length > 1 ? barData[1][0] - barData[0][0] : 0.05;\n    data.push({\n      data: barData,\n      bars: {\n        show: true,\n        align: \"center\",\n        barWidth: width\n      },\n      color: 1\n    });\n  }\n\n  const percSmallerLarger = (comp, data) => {\n    const percLarger = jStat.mean(jStat.map(data, x => x >= comp ? 1 : 0));\n    return [1 - percLarger, percLarger];\n  };\n  if (typeof conf.compValue === 'number') {\n    const compPerc = percSmallerLarger(conf.compValue, paramData);\n    data.push({\n      data: [[conf.compValue, 0], [conf.compValue, Infinity]],\n      label: \"\" + (compPerc[0] * 100).toPrecision(3) + \"% < \" +\n        conf.compValue + \" < \" + (compPerc[1] * 100).toPrecision(3) + \"%\",\n      lines: {lineWidth: 2},\n      color: 2\n    });\n  }\n\n  const boundedI = (c, x) => {\n    x = x.sort((a, b) => a - b);\n    const nbrPoints = Math.floor(x.length * c);\n    const upper = [x[x.length - 1 - nbrPoints], interval[1]];\n    const lower = [interval[0], x[nbrPoints]];\n    return -upper[0] < lower[1] ? upper : lower;\n  };\n  const HDI = (c, x) => {\n    x = x.sort((a, b) => a - b);\n    const nbrPoints = Math.floor(x.length * c);\n    let [min, max] = [jStat.min(x), jStat.max(x)];\n    let width;\n    for (let i = 0, l = x.length - nbrPoints; i < l; i++) {\n      width = x[i + nbrPoints] - x[i];\n      if (width < max - min) {\n        [min, max] = [x[i], x[i + nbrPoints]];\n      }\n    }\n    return [min, max];\n  };\n  if (typeof conf.di !== 'undefined' && conf.di !== null) {\n    const intervAdd = (c, [min, max]) => {\n      data.push({\n        data: [\n          [min, plot.getHeight(min === interval[0] ? max : min, barData)],\n          [max, plot.getHeight(max === interval[1] ? min : max, barData)]\n        ],\n        label: c.toPrecision(2).slice(2) + '% ' + conf.di + ' ('+\n          min.toPrecision(3) + ', ' + max.toPrecision(3) +')',\n        lines: { lineWidth: 5 },\n        color: 3\n      });\n    };\n    if (conf.di === 'BI') {\n      [0.95, 0.99].forEach(c => {\n        intervAdd(c, boundedI(c, paramData));\n      });\n    } else {\n      [0.95].forEach(c => {\n        intervAdd(c, HDI(c, paramData));\n      });\n    }\n  }\n  if (typeof paramData.length !== 'undefined' && paramData.length !== 0) {\n    const mean = jStat.mean(paramData);\n    data.push({data: [[mean, 0]],\n               label: 'Mean: ' + mean.toPrecision(3),\n               points: { show: true },\n               color: 4\n              });\n  }\n  return $.plot(jq, data, plotOpts);\n};\n\nconst best = ds => {\n  const showResult = chain => {\n    inputGraph(mcmc.posterior_predictive_check(chain));\n    progress(0.925);\n\n    $('#stat-out').show();\n    plotMcmcHist($(\"#mean > div\"),\n                 plot.twoDArrayCol(chain, 2),\n                 {di: 'BI', comp: 0, xlims: [-1, 1]}\n                );\n    progress(0.95);\n\n    const a = plot.twoDArrayCol(chain, 0);\n    const b = plot.twoDArrayCol(chain, 1);\n    const xlims = plot.xHistLims([a, b]);\n    const ylims = plot.yHistLims([a, b]);\n    plotMcmcHist($(\"#alpha > div\"), a, { di: 'HDI', xlims, ylims, log: true });\n    progress(0.975);\n    plotMcmcHist($(\"#beta > div\"), b, { di: 'HDI', xlims, ylims, log: true });\n    progress(1);\n  };\n  const progress = x => {\n    $('progress').attr('value', x);\n  };\n  \n  $(\".analyze\").html('Re-analyze');\n  mcmc.run_BEST(ds, 20000, 20000, progress, showResult);\n};\n\nconst freq = ds => {\n  const l = ds.length;\n  const dof = l - 1;\n  if (l < 30) {\n    alert('We need at least 30 votes for this calculation. You need at least ' + (30 - l) + ' more.');\n    return;\n  }\n\n  const mean = jStat.mean(ds);\n  const stdev = jStat.stdev(ds);\n  const cis = plot.sampleFunc(-1, 1, mu =>\n    jStat.studentt.pdf((mean - mu) / stdev * Math.sqrt(l), dof)\n  );\n  const ci = conf => {\n    const bound = jStat.studentt.inv(conf, dof) * stdev / Math.sqrt(l);\n    const y = jStat.studentt.pdf(jStat.studentt.inv(conf, dof), dof);\n    if (mean > 0) {\n      return [y, mean - bound, Infinity];\n    } else {\n      return [y, -Infinity, mean + bound];\n    }\n  };\n  const data = [{\n    data: cis,\n    lines: {show: true},\n    color: 1\n  },{\n    data: [[mean, 0]],\n    label: \"Mean: \" + mean.toPrecision(3),\n    points: {show: true},\n    color: 4\n  }];\n  [0.95, 0.99].forEach(conf => {\n    const [y, lb, ub] = ci(conf);\n    data.push({\n      data: [[lb, y], [ub, y]],\n      label: conf.toPrecision(2).slice(2) + \"% CI (\"+\n        lb.toPrecision(3) + \", \" + ub.toPrecision(3) +\")\",\n      lines: {lineWidth: 5},\n      color: 3\n    });\n  });\n  $('#stat-out').show();\n  $.plot($('#freq > div'), data, plotOptions);\n  $('progress').attr('value', 1);\n};\n\nconst getData = check => {\n  const stringToNums = s => {\n    s = s.replace(/[^-1234567890.]+$/, '').replace(/^[^-1234567890.]+/, '');\n    return jStat.map(s.split(/[^-1234567890.]+/), x => {\n      const f = parseFloat(x);\n      if (isNaN(f)) {\n        throw \"NaN\";\n      }\n      // If we let in 0 or 1, we end up taking log(0) later\n      const eps = 0.001;\n      if (f <= 0) {\n        return eps;\n      }\n      if (f >= 1) {\n        return 1 - eps;\n      }\n      return f;\n    });\n  };\n  let y1, y2;\n  try {\n    y1 = stringToNums($(\"#data1\").val());\n    y2 = stringToNums($(\"#data2\").val());\n  } catch(err) {\n    alert(\"ERROR: Data not supplied for both groups or not formatted correctly.\");\n    return null;\n  }\n  const dif = y2.length - y1.length;\n  if (dif !== 0 && check === true) {\n    const err = \" Since we're supposed to pair data, that's bad.\";\n    if (dif > 0) {\n      alert(\"You have \" + dif + \" more data points for Proposal 2 than for Proposal 1.\" + err);\n      return null;\n    } else {\n      alert(\"You have \" + -dif + \" more data points for Proposal 1 than for Proposal 2.\" + err);\n      return null;\n    }\n  }\n  const ds = [];\n  const l = Math.min(y1.length, y2.length);\n  for (let i = 0; i < l; i++) {\n    ds.push(y2[i] - y1[i]);\n  }\n  return [y1, y2, ds];\n};\n\nconst inputGraph = pred => {\n  const ys = getData();\n  if (typeof ys === 'undefined') { return; }\n  const ylims = plot.yHistLims(ys);\n  plotMcmcHist($('#preview1 > div'), ys[0], {xlims: [0, 1], ylims});\n  plotMcmcHist($('#preview2 > div'), ys[1], {xlims: [0, 1], ylims});\n  plotMcmcHist($('#diff > div'), ys[2], {xlims: [-1, 1]}, pred);\n};\n\n$(() => {\n\n$(\".act > .analyze\").click(() => {\n  const d = getData(true);\n  if (typeof d === 'undefined') { return; }\n  if ($('#best').closest('li').hasClass('open')) {\n    best(d[2]);\n  } else {\n    freq(d[2]);\n  }\n});\n$(\".preview\").click(() => {inputGraph();});\n\n// For reasons unkown, setTimeout is required\nsetTimeout(function(){inputGraph();});\nconst plotOpts = {\n  grid: { show: false },\n  colors: [colors.value[3]]\n};\n$.plot($('#non-norm'),\n  [{\n    bars: { show: true },\n    data: [[-2, 4], [-1, 1], [0, 0], [1, 1], [2, 4]]\n  }], plotOpts);\n$.plot($('#sym1'),\n  [{\n    bars: { show: true },\n    data: [[-2, 1], [-1, 0], [0, 0], [1, 2], [2, 0]]\n  }], plotOpts);\n$.plot($('#sym2'),\n  [{ bars: { show: true },\n     data: [[-2, 0], [-1, 0], [0, 3], [1, 0], [2, 0]]\n   }], plotOpts);\n\n});\n\n\n\n// WEBPACK FOOTER //\n// ./js/quorum.wp.es.js","/*** IMPORTS FROM imports-loader ***/\nvar $ = require(\"jquery\");\nvar jQuery = require(\"jquery\");\n\n/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n\n// first an inline dependency, jquery.colorhelpers.js, we inline it here\n// for convenience\n\n/* Plugin for jQuery for working with colors.\n *\n * Version 1.1.\n *\n * Inspiration from jQuery color animation plugin by John Resig.\n *\n * Released under the MIT license by Ole Laursen, October 2009.\n *\n * Examples:\n *\n *   $.color.parse(\"#fff\").scale('rgb', 0.25).add('a', -0.5).toString()\n *   var c = $.color.extract($(\"#mydiv\"), 'background-color');\n *   console.log(c.r, c.g, c.b, c.a);\n *   $.color.make(100, 50, 25, 0.4).toString() // returns \"rgba(100,50,25,0.4)\"\n *\n * Note that .scale() and .add() return the same modified object\n * instead of making a new one.\n *\n * V. 1.1: Fix error handling so e.g. parsing an empty string does\n * produce a color rather than just crashing.\n */\n(function($){$.color={};$.color.make=function(r,g,b,a){var o={};o.r=r||0;o.g=g||0;o.b=b||0;o.a=a!=null?a:1;o.add=function(c,d){for(var i=0;i<c.length;++i)o[c.charAt(i)]+=d;return o.normalize()};o.scale=function(c,f){for(var i=0;i<c.length;++i)o[c.charAt(i)]*=f;return o.normalize()};o.toString=function(){if(o.a>=1){return\"rgb(\"+[o.r,o.g,o.b].join(\",\")+\")\"}else{return\"rgba(\"+[o.r,o.g,o.b,o.a].join(\",\")+\")\"}};o.normalize=function(){function clamp(min,value,max){return value<min?min:value>max?max:value}o.r=clamp(0,parseInt(o.r),255);o.g=clamp(0,parseInt(o.g),255);o.b=clamp(0,parseInt(o.b),255);o.a=clamp(0,o.a,1);return o};o.clone=function(){return $.color.make(o.r,o.b,o.g,o.a)};return o.normalize()};$.color.extract=function(elem,css){var c;do{c=elem.css(css).toLowerCase();if(c!=\"\"&&c!=\"transparent\")break;elem=elem.parent()}while(elem.length&&!$.nodeName(elem.get(0),\"body\"));if(c==\"rgba(0, 0, 0, 0)\")c=\"transparent\";return $.color.parse(c)};$.color.parse=function(str){var res,m=$.color.make;if(res=/rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10));if(res=/rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseInt(res[1],10),parseInt(res[2],10),parseInt(res[3],10),parseFloat(res[4]));if(res=/rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55);if(res=/rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str))return m(parseFloat(res[1])*2.55,parseFloat(res[2])*2.55,parseFloat(res[3])*2.55,parseFloat(res[4]));if(res=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str))return m(parseInt(res[1],16),parseInt(res[2],16),parseInt(res[3],16));if(res=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str))return m(parseInt(res[1]+res[1],16),parseInt(res[2]+res[2],16),parseInt(res[3]+res[3],16));var name=$.trim(str).toLowerCase();if(name==\"transparent\")return m(255,255,255,0);else{res=lookupColors[name]||[0,0,0];return m(res[0],res[1],res[2])}};var lookupColors={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0]}})(jQuery);\n\n// the actual Flot code\n(function($) {\n\n\t// Cache the prototype hasOwnProperty for faster access\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    // A shim to provide 'detach' to jQuery versions prior to 1.4.  Using a DOM\n    // operation produces the same effect as detach, i.e. removing the element\n    // without touching its jQuery data.\n\n    // Do not merge this into Flot 0.9, since it requires jQuery 1.4.4+.\n\n    if (!$.fn.detach) {\n        $.fn.detach = function() {\n            return this.each(function() {\n                if (this.parentNode) {\n                    this.parentNode.removeChild( this );\n                }\n            });\n        };\n    }\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The Canvas object is a wrapper around an HTML5 <canvas> tag.\n\t//\n\t// @constructor\n\t// @param {string} cls List of classes to apply to the canvas.\n\t// @param {element} container Element onto which to append the canvas.\n\t//\n\t// Requiring a container is a little iffy, but unfortunately canvas\n\t// operations don't work unless the canvas is attached to the DOM.\n\n\tfunction Canvas(cls, container) {\n\n\t\tvar element = container.children(\".\" + cls)[0];\n\n\t\tif (element == null) {\n\n\t\t\telement = document.createElement(\"canvas\");\n\t\t\telement.className = cls;\n\n\t\t\t$(element).css({ direction: \"ltr\", position: \"absolute\", left: 0, top: 0 })\n\t\t\t\t.appendTo(container);\n\n\t\t\t// If HTML5 Canvas isn't available, fall back to [Ex|Flash]canvas\n\n\t\t\tif (!element.getContext) {\n\t\t\t\tif (window.G_vmlCanvasManager) {\n\t\t\t\t\telement = window.G_vmlCanvasManager.initElement(element);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.element = element;\n\n\t\tvar context = this.context = element.getContext(\"2d\");\n\n\t\t// Determine the screen's ratio of physical to device-independent\n\t\t// pixels.  This is the ratio between the canvas width that the browser\n\t\t// advertises and the number of pixels actually present in that space.\n\n\t\t// The iPhone 4, for example, has a device-independent width of 320px,\n\t\t// but its screen is actually 640px wide.  It therefore has a pixel\n\t\t// ratio of 2, while most normal devices have a ratio of 1.\n\n\t\tvar devicePixelRatio = window.devicePixelRatio || 1,\n\t\t\tbackingStoreRatio =\n\t\t\t\tcontext.webkitBackingStorePixelRatio ||\n\t\t\t\tcontext.mozBackingStorePixelRatio ||\n\t\t\t\tcontext.msBackingStorePixelRatio ||\n\t\t\t\tcontext.oBackingStorePixelRatio ||\n\t\t\t\tcontext.backingStorePixelRatio || 1;\n\n\t\tthis.pixelRatio = devicePixelRatio / backingStoreRatio;\n\n\t\t// Size the canvas to match the internal dimensions of its container\n\n\t\tthis.resize(container.width(), container.height());\n\n\t\t// Collection of HTML div layers for text overlaid onto the canvas\n\n\t\tthis.textContainer = null;\n\t\tthis.text = {};\n\n\t\t// Cache of text fragments and metrics, so we can avoid expensively\n\t\t// re-calculating them when the plot is re-rendered in a loop.\n\n\t\tthis._textCache = {};\n\t}\n\n\t// Resizes the canvas to the given dimensions.\n\t//\n\t// @param {number} width New width of the canvas, in pixels.\n\t// @param {number} width New height of the canvas, in pixels.\n\n\tCanvas.prototype.resize = function(width, height) {\n\n\t\tif (width <= 0 || height <= 0) {\n\t\t\tthrow new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height);\n\t\t}\n\n\t\tvar element = this.element,\n\t\t\tcontext = this.context,\n\t\t\tpixelRatio = this.pixelRatio;\n\n\t\t// Resize the canvas, increasing its density based on the display's\n\t\t// pixel ratio; basically giving it more pixels without increasing the\n\t\t// size of its element, to take advantage of the fact that retina\n\t\t// displays have that many more pixels in the same advertised space.\n\n\t\t// Resizing should reset the state (excanvas seems to be buggy though)\n\n\t\tif (this.width != width) {\n\t\t\telement.width = width * pixelRatio;\n\t\t\telement.style.width = width + \"px\";\n\t\t\tthis.width = width;\n\t\t}\n\n\t\tif (this.height != height) {\n\t\t\telement.height = height * pixelRatio;\n\t\t\telement.style.height = height + \"px\";\n\t\t\tthis.height = height;\n\t\t}\n\n\t\t// Save the context, so we can reset in case we get replotted.  The\n\t\t// restore ensure that we're really back at the initial state, and\n\t\t// should be safe even if we haven't saved the initial state yet.\n\n\t\tcontext.restore();\n\t\tcontext.save();\n\n\t\t// Scale the coordinate space to match the display density; so even though we\n\t\t// may have twice as many pixels, we still want lines and other drawing to\n\t\t// appear at the same size; the extra pixels will just make them crisper.\n\n\t\tcontext.scale(pixelRatio, pixelRatio);\n\t};\n\n\t// Clears the entire canvas area, not including any overlaid HTML text\n\n\tCanvas.prototype.clear = function() {\n\t\tthis.context.clearRect(0, 0, this.width, this.height);\n\t};\n\n\t// Finishes rendering the canvas, including managing the text overlay.\n\n\tCanvas.prototype.render = function() {\n\n\t\tvar cache = this._textCache;\n\n\t\t// For each text layer, add elements marked as active that haven't\n\t\t// already been rendered, and remove those that are no longer active.\n\n\t\tfor (var layerKey in cache) {\n\t\t\tif (hasOwnProperty.call(cache, layerKey)) {\n\n\t\t\t\tvar layer = this.getTextLayer(layerKey),\n\t\t\t\t\tlayerCache = cache[layerKey];\n\n\t\t\t\tlayer.hide();\n\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tif (position.active) {\n\t\t\t\t\t\t\t\t\t\tif (!position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tlayer.append(position.element);\n\t\t\t\t\t\t\t\t\t\t\tposition.rendered = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpositions.splice(i--, 1);\n\t\t\t\t\t\t\t\t\t\tif (position.rendered) {\n\t\t\t\t\t\t\t\t\t\t\tposition.element.detach();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (positions.length == 0) {\n\t\t\t\t\t\t\t\t\tdelete styleCache[key];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayer.show();\n\t\t\t}\n\t\t}\n\t};\n\n\t// Creates (if necessary) and returns the text overlay container.\n\t//\n\t// @param {string} classes String of space-separated CSS classes used to\n\t//     uniquely identify the text layer.\n\t// @return {object} The jQuery-wrapped text-layer div.\n\n\tCanvas.prototype.getTextLayer = function(classes) {\n\n\t\tvar layer = this.text[classes];\n\n\t\t// Create the text layer if it doesn't exist\n\n\t\tif (layer == null) {\n\n\t\t\t// Create the text layer container, if it doesn't exist\n\n\t\t\tif (this.textContainer == null) {\n\t\t\t\tthis.textContainer = $(\"<div class='flot-text'></div>\")\n\t\t\t\t\t.css({\n\t\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tbottom: 0,\n\t\t\t\t\t\tright: 0,\n\t\t\t\t\t\t'font-size': \"smaller\",\n\t\t\t\t\t\tcolor: \"#545454\"\n\t\t\t\t\t})\n\t\t\t\t\t.insertAfter(this.element);\n\t\t\t}\n\n\t\t\tlayer = this.text[classes] = $(\"<div></div>\")\n\t\t\t\t.addClass(classes)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\ttop: 0,\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tbottom: 0,\n\t\t\t\t\tright: 0\n\t\t\t\t})\n\t\t\t\t.appendTo(this.textContainer);\n\t\t}\n\n\t\treturn layer;\n\t};\n\n\t// Creates (if necessary) and returns a text info object.\n\t//\n\t// The object looks like this:\n\t//\n\t// {\n\t//     width: Width of the text's wrapper div.\n\t//     height: Height of the text's wrapper div.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     positions: Array of positions at which this text is drawn.\n\t// }\n\t//\n\t// The positions array contains objects that look like this:\n\t//\n\t// {\n\t//     active: Flag indicating whether the text should be visible.\n\t//     rendered: Flag indicating whether the text is currently visible.\n\t//     element: The jQuery-wrapped HTML div containing the text.\n\t//     x: X coordinate at which to draw the text.\n\t//     y: Y coordinate at which to draw the text.\n\t// }\n\t//\n\t// Each position after the first receives a clone of the original element.\n\t//\n\t// The idea is that that the width, height, and general 'identity' of the\n\t// text is constant no matter where it is placed; the placements are a\n\t// secondary property.\n\t//\n\t// Canvas maintains a cache of recently-used text info objects; getTextInfo\n\t// either returns the cached element or creates a new entry.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {string} text Text string to retrieve info for.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @return {object} a text info object.\n\n\tCanvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n\n\t\tvar textStyle, layerCache, styleCache, info;\n\n\t\t// Cast the value to a string, in case we were given a number or such\n\n\t\ttext = \"\" + text;\n\n\t\t// If the font is a font-spec object, generate a CSS font definition\n\n\t\tif (typeof font === \"object\") {\n\t\t\ttextStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family;\n\t\t} else {\n\t\t\ttextStyle = font;\n\t\t}\n\n\t\t// Retrieve (or create) the cache for the text's layer and styles\n\n\t\tlayerCache = this._textCache[layer];\n\n\t\tif (layerCache == null) {\n\t\t\tlayerCache = this._textCache[layer] = {};\n\t\t}\n\n\t\tstyleCache = layerCache[textStyle];\n\n\t\tif (styleCache == null) {\n\t\t\tstyleCache = layerCache[textStyle] = {};\n\t\t}\n\n\t\tinfo = styleCache[text];\n\n\t\t// If we can't find a matching element in our cache, create a new one\n\n\t\tif (info == null) {\n\n\t\t\tvar element = $(\"<div></div>\").html(text)\n\t\t\t\t.css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\t'max-width': width,\n\t\t\t\t\ttop: -9999\n\t\t\t\t})\n\t\t\t\t.appendTo(this.getTextLayer(layer));\n\n\t\t\tif (typeof font === \"object\") {\n\t\t\t\telement.css({\n\t\t\t\t\tfont: textStyle,\n\t\t\t\t\tcolor: font.color\n\t\t\t\t});\n\t\t\t} else if (typeof font === \"string\") {\n\t\t\t\telement.addClass(font);\n\t\t\t}\n\n\t\t\tinfo = styleCache[text] = {\n\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\theight: element.outerHeight(true),\n\t\t\t\telement: element,\n\t\t\t\tpositions: []\n\t\t\t};\n\n\t\t\telement.detach();\n\t\t}\n\n\t\treturn info;\n\t};\n\n\t// Adds a text string to the canvas text overlay.\n\t//\n\t// The text isn't drawn immediately; it is marked as rendering, which will\n\t// result in its addition to the canvas on the next render pass.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number} x X coordinate at which to draw the text.\n\t// @param {number} y Y coordinate at which to draw the text.\n\t// @param {string} text Text string to draw.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which to rotate the text, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\t// @param {number=} width Maximum width of the text before it wraps.\n\t// @param {string=} halign Horizontal alignment of the text; either \"left\",\n\t//     \"center\" or \"right\".\n\t// @param {string=} valign Vertical alignment of the text; either \"top\",\n\t//     \"middle\" or \"bottom\".\n\n\tCanvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n\n\t\tvar info = this.getTextInfo(layer, text, font, angle, width),\n\t\t\tpositions = info.positions;\n\n\t\t// Tweak the div's position to match the text's alignment\n\n\t\tif (halign == \"center\") {\n\t\t\tx -= info.width / 2;\n\t\t} else if (halign == \"right\") {\n\t\t\tx -= info.width;\n\t\t}\n\n\t\tif (valign == \"middle\") {\n\t\t\ty -= info.height / 2;\n\t\t} else if (valign == \"bottom\") {\n\t\t\ty -= info.height;\n\t\t}\n\n\t\t// Determine whether this text already exists at this position.\n\t\t// If so, mark it for inclusion in the next render pass.\n\n\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\tposition.active = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the text doesn't exist at this position, create a new entry\n\n\t\t// For the very first position we'll re-use the original element,\n\t\t// while for subsequent ones we'll clone it.\n\n\t\tposition = {\n\t\t\tactive: true,\n\t\t\trendered: false,\n\t\t\telement: positions.length ? info.element.clone() : info.element,\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\n\t\tpositions.push(position);\n\n\t\t// Move the element to its final position within the container\n\n\t\tposition.element.css({\n\t\t\ttop: Math.round(y),\n\t\t\tleft: Math.round(x),\n\t\t\t'text-align': halign\t// In case the text wraps\n\t\t});\n\t};\n\n\t// Removes one or more text strings from the canvas text overlay.\n\t//\n\t// If no parameters are given, all text within the layer is removed.\n\t//\n\t// Note that the text is not immediately removed; it is simply marked as\n\t// inactive, which will result in its removal on the next render pass.\n\t// This avoids the performance penalty for 'clear and redraw' behavior,\n\t// where we potentially get rid of all text on a layer, but will likely\n\t// add back most or all of it later, as when redrawing axes, for example.\n\t//\n\t// @param {string} layer A string of space-separated CSS classes uniquely\n\t//     identifying the layer containing this text.\n\t// @param {number=} x X coordinate of the text.\n\t// @param {number=} y Y coordinate of the text.\n\t// @param {string=} text Text string to remove.\n\t// @param {(string|object)=} font Either a string of space-separated CSS\n\t//     classes or a font-spec object, defining the text's font and style.\n\t// @param {number=} angle Angle at which the text is rotated, in degrees.\n\t//     Angle is currently unused, it will be implemented in the future.\n\n\tCanvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n\t\tif (text == null) {\n\t\t\tvar layerCache = this._textCache[layer];\n\t\t\tif (layerCache != null) {\n\t\t\t\tfor (var styleKey in layerCache) {\n\t\t\t\t\tif (hasOwnProperty.call(layerCache, styleKey)) {\n\t\t\t\t\t\tvar styleCache = layerCache[styleKey];\n\t\t\t\t\t\tfor (var key in styleCache) {\n\t\t\t\t\t\t\tif (hasOwnProperty.call(styleCache, key)) {\n\t\t\t\t\t\t\t\tvar positions = styleCache[key].positions;\n\t\t\t\t\t\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\t\t\t\t\t\tposition.active = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar positions = this.getTextInfo(layer, text, font, angle).positions;\n\t\t\tfor (var i = 0, position; position = positions[i]; i++) {\n\t\t\t\tif (position.x == x && position.y == y) {\n\t\t\t\t\tposition.active = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// The top-level container for the entire plot.\n\n    function Plot(placeholder, data_, options_, plugins) {\n        // data is on the form:\n        //   [ series1, series2 ... ]\n        // where series is either just the data as [ [x1, y1], [x2, y2], ... ]\n        // or { data: [ [x1, y1], [x2, y2], ... ], label: \"some label\", ... }\n\n        var series = [],\n            options = {\n                // the color theme used for graphs\n                colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n                legend: {\n                    show: true,\n                    noColumns: 1, // number of colums in legend table\n                    labelFormatter: null, // fn: string -> string\n                    labelBoxBorderColor: \"#ccc\", // border color for the little label boxes\n                    container: null, // container (as jQuery object) to put legend in, null means default on top of graph\n                    position: \"ne\", // position of default legend container within plot\n                    margin: 5, // distance from grid edge to default legend container within plot\n                    backgroundColor: null, // null means auto-detect\n                    backgroundOpacity: 0.85, // set to 0 to avoid background\n                    sorted: null    // default to no legend sorting\n                },\n                xaxis: {\n                    show: null, // null = auto-detect, true = always, false = never\n                    position: \"bottom\", // or \"top\"\n                    mode: null, // null or \"time\"\n                    font: null, // null (derived from CSS in placeholder) or object like { size: 11, lineHeight: 13, style: \"italic\", weight: \"bold\", family: \"sans-serif\", variant: \"small-caps\" }\n                    color: null, // base color, labels, ticks\n                    tickColor: null, // possibly different color of ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    transform: null, // null or f: number -> number to transform axis\n                    inverseTransform: null, // if transform is set, this should be the inverse function\n                    min: null, // min. value to show, null means set automatically\n                    max: null, // max. value to show, null means set automatically\n                    autoscaleMargin: null, // margin in % to add if auto-setting min/max\n                    ticks: null, // either [1, 3] or [[1, \"a\"], 3] or (fn: axis info -> ticks) or app. number of ticks for auto-ticks\n                    tickFormatter: null, // fn: number -> string\n                    labelWidth: null, // size of tick labels in pixels\n                    labelHeight: null,\n                    reserveSpace: null, // whether to reserve space even if axis isn't shown\n                    tickLength: null, // size in pixels of ticks, or \"full\" for whole line\n                    alignTicksWithAxis: null, // axis number or null for no sync\n                    tickDecimals: null, // no. of decimals, null means auto\n                    tickSize: null, // number or [number, \"unit\"]\n                    minTickSize: null // number or [number, \"unit\"]\n                },\n                yaxis: {\n                    autoscaleMargin: 0.02,\n                    position: \"left\" // or \"right\"\n                },\n                xaxes: [],\n                yaxes: [],\n                series: {\n                    points: {\n                        show: false,\n                        radius: 3,\n                        lineWidth: 2, // in pixels\n                        fill: true,\n                        fillColor: \"#ffffff\",\n                        symbol: \"circle\" // or callback\n                    },\n                    lines: {\n                        // we don't put in show: false so we can see\n                        // whether lines were actively disabled\n                        lineWidth: 2, // in pixels\n                        fill: false,\n                        fillColor: null,\n                        steps: false\n                        // Omit 'zero', so we can later default its value to\n                        // match that of the 'fill' option.\n                    },\n                    bars: {\n                        show: false,\n                        lineWidth: 2, // in pixels\n                        barWidth: 1, // in units of the x axis\n                        fill: true,\n                        fillColor: null,\n                        align: \"left\", // \"left\", \"right\", or \"center\"\n                        horizontal: false,\n                        zero: true\n                    },\n                    shadowSize: 3,\n                    highlightColor: null\n                },\n                grid: {\n                    show: true,\n                    aboveData: false,\n                    color: \"#545454\", // primary color used for outline and labels\n                    backgroundColor: null, // null for transparent, else color\n                    borderColor: null, // set if different from the grid color\n                    tickColor: null, // color for the ticks, e.g. \"rgba(0,0,0,0.15)\"\n                    margin: 0, // distance from the canvas edge to the grid\n                    labelMargin: 5, // in pixels\n                    axisMargin: 8, // in pixels\n                    borderWidth: 2, // in pixels\n                    minBorderMargin: null, // in pixels, null means taken from points radius\n                    markings: null, // array of ranges or fn: axes -> array of ranges\n                    markingsColor: \"#f4f4f4\",\n                    markingsLineWidth: 2,\n                    // interactive stuff\n                    clickable: false,\n                    hoverable: false,\n                    autoHighlight: true, // highlight in case mouse is near\n                    mouseActiveRadius: 10 // how far the mouse can be away to activate an item\n                },\n                interaction: {\n                    redrawOverlayInterval: 1000/60 // time between updates, -1 means in same flow\n                },\n                hooks: {}\n            },\n        surface = null,     // the canvas for the plot itself\n        overlay = null,     // canvas for interactive stuff on top of plot\n        eventHolder = null, // jQuery object that events should be bound to\n        ctx = null, octx = null,\n        xaxes = [], yaxes = [],\n        plotOffset = { left: 0, right: 0, top: 0, bottom: 0},\n        plotWidth = 0, plotHeight = 0,\n        hooks = {\n            processOptions: [],\n            processRawData: [],\n            processDatapoints: [],\n            processOffset: [],\n            drawBackground: [],\n            drawSeries: [],\n            draw: [],\n            bindEvents: [],\n            drawOverlay: [],\n            shutdown: []\n        },\n        plot = this;\n\n        // public functions\n        plot.setData = setData;\n        plot.setupGrid = setupGrid;\n        plot.draw = draw;\n        plot.getPlaceholder = function() { return placeholder; };\n        plot.getCanvas = function() { return surface.element; };\n        plot.getPlotOffset = function() { return plotOffset; };\n        plot.width = function () { return plotWidth; };\n        plot.height = function () { return plotHeight; };\n        plot.offset = function () {\n            var o = eventHolder.offset();\n            o.left += plotOffset.left;\n            o.top += plotOffset.top;\n            return o;\n        };\n        plot.getData = function () { return series; };\n        plot.getAxes = function () {\n            var res = {}, i;\n            $.each(xaxes.concat(yaxes), function (_, axis) {\n                if (axis)\n                    res[axis.direction + (axis.n != 1 ? axis.n : \"\") + \"axis\"] = axis;\n            });\n            return res;\n        };\n        plot.getXAxes = function () { return xaxes; };\n        plot.getYAxes = function () { return yaxes; };\n        plot.c2p = canvasToAxisCoords;\n        plot.p2c = axisToCanvasCoords;\n        plot.getOptions = function () { return options; };\n        plot.highlight = highlight;\n        plot.unhighlight = unhighlight;\n        plot.triggerRedrawOverlay = triggerRedrawOverlay;\n        plot.pointOffset = function(point) {\n            return {\n                left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c(+point.x) + plotOffset.left, 10),\n                top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c(+point.y) + plotOffset.top, 10)\n            };\n        };\n        plot.shutdown = shutdown;\n        plot.destroy = function () {\n            shutdown();\n            placeholder.removeData(\"plot\").empty();\n\n            series = [];\n            options = null;\n            surface = null;\n            overlay = null;\n            eventHolder = null;\n            ctx = null;\n            octx = null;\n            xaxes = [];\n            yaxes = [];\n            hooks = null;\n            highlights = [];\n            plot = null;\n        };\n        plot.resize = function () {\n        \tvar width = placeholder.width(),\n        \t\theight = placeholder.height();\n            surface.resize(width, height);\n            overlay.resize(width, height);\n        };\n\n        // public attributes\n        plot.hooks = hooks;\n\n        // initialize\n        initPlugins(plot);\n        parseOptions(options_);\n        setupCanvases();\n        setData(data_);\n        setupGrid();\n        draw();\n        bindEvents();\n\n\n        function executeHooks(hook, args) {\n            args = [plot].concat(args);\n            for (var i = 0; i < hook.length; ++i)\n                hook[i].apply(this, args);\n        }\n\n        function initPlugins() {\n\n            // References to key classes, allowing plugins to modify them\n\n            var classes = {\n                Canvas: Canvas\n            };\n\n            for (var i = 0; i < plugins.length; ++i) {\n                var p = plugins[i];\n                p.init(plot, classes);\n                if (p.options)\n                    $.extend(true, options, p.options);\n            }\n        }\n\n        function parseOptions(opts) {\n\n            $.extend(true, options, opts);\n\n            // $.extend merges arrays, rather than replacing them.  When less\n            // colors are provided than the size of the default palette, we\n            // end up with those colors plus the remaining defaults, which is\n            // not expected behavior; avoid it by replacing them here.\n\n            if (opts && opts.colors) {\n            \toptions.colors = opts.colors;\n            }\n\n            if (options.xaxis.color == null)\n                options.xaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n            if (options.yaxis.color == null)\n                options.yaxis.color = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            if (options.xaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n            if (options.yaxis.tickColor == null) // grid.tickColor for back-compatibility\n                options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n\n            if (options.grid.borderColor == null)\n                options.grid.borderColor = options.grid.color;\n            if (options.grid.tickColor == null)\n                options.grid.tickColor = $.color.parse(options.grid.color).scale('a', 0.22).toString();\n\n            // Fill in defaults for axis options, including any unspecified\n            // font-spec fields, if a font-spec was provided.\n\n            // If no x/y axis options were provided, create one of each anyway,\n            // since the rest of the code assumes that they exist.\n\n            var i, axisOptions, axisCount,\n                fontSize = placeholder.css(\"font-size\"),\n                fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n                fontDefaults = {\n                    style: placeholder.css(\"font-style\"),\n                    size: Math.round(0.8 * fontSizeDefault),\n                    variant: placeholder.css(\"font-variant\"),\n                    weight: placeholder.css(\"font-weight\"),\n                    family: placeholder.css(\"font-family\")\n                };\n\n            axisCount = options.xaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.xaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.xaxis, axisOptions);\n                options.xaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            axisCount = options.yaxes.length || 1;\n            for (i = 0; i < axisCount; ++i) {\n\n                axisOptions = options.yaxes[i];\n                if (axisOptions && !axisOptions.tickColor) {\n                    axisOptions.tickColor = axisOptions.color;\n                }\n\n                axisOptions = $.extend(true, {}, options.yaxis, axisOptions);\n                options.yaxes[i] = axisOptions;\n\n                if (axisOptions.font) {\n                    axisOptions.font = $.extend({}, fontDefaults, axisOptions.font);\n                    if (!axisOptions.font.color) {\n                        axisOptions.font.color = axisOptions.color;\n                    }\n                    if (!axisOptions.font.lineHeight) {\n                        axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15);\n                    }\n                }\n            }\n\n            // backwards compatibility, to be removed in future\n            if (options.xaxis.noTicks && options.xaxis.ticks == null)\n                options.xaxis.ticks = options.xaxis.noTicks;\n            if (options.yaxis.noTicks && options.yaxis.ticks == null)\n                options.yaxis.ticks = options.yaxis.noTicks;\n            if (options.x2axis) {\n                options.xaxes[1] = $.extend(true, {}, options.xaxis, options.x2axis);\n                options.xaxes[1].position = \"top\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.x2axis.min == null) {\n                    options.xaxes[1].min = null;\n                }\n                if (options.x2axis.max == null) {\n                    options.xaxes[1].max = null;\n                }\n            }\n            if (options.y2axis) {\n                options.yaxes[1] = $.extend(true, {}, options.yaxis, options.y2axis);\n                options.yaxes[1].position = \"right\";\n                // Override the inherit to allow the axis to auto-scale\n                if (options.y2axis.min == null) {\n                    options.yaxes[1].min = null;\n                }\n                if (options.y2axis.max == null) {\n                    options.yaxes[1].max = null;\n                }\n            }\n            if (options.grid.coloredAreas)\n                options.grid.markings = options.grid.coloredAreas;\n            if (options.grid.coloredAreasColor)\n                options.grid.markingsColor = options.grid.coloredAreasColor;\n            if (options.lines)\n                $.extend(true, options.series.lines, options.lines);\n            if (options.points)\n                $.extend(true, options.series.points, options.points);\n            if (options.bars)\n                $.extend(true, options.series.bars, options.bars);\n            if (options.shadowSize != null)\n                options.series.shadowSize = options.shadowSize;\n            if (options.highlightColor != null)\n                options.series.highlightColor = options.highlightColor;\n\n            // save options on axes for future reference\n            for (i = 0; i < options.xaxes.length; ++i)\n                getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n            for (i = 0; i < options.yaxes.length; ++i)\n                getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n\n            // add hooks from options\n            for (var n in hooks)\n                if (options.hooks[n] && options.hooks[n].length)\n                    hooks[n] = hooks[n].concat(options.hooks[n]);\n\n            executeHooks(hooks.processOptions, [options]);\n        }\n\n        function setData(d) {\n            series = parseData(d);\n            fillInSeriesOptions();\n            processData();\n        }\n\n        function parseData(d) {\n            var res = [];\n            for (var i = 0; i < d.length; ++i) {\n                var s = $.extend(true, {}, options.series);\n\n                if (d[i].data != null) {\n                    s.data = d[i].data; // move the data instead of deep-copy\n                    delete d[i].data;\n\n                    $.extend(true, s, d[i]);\n\n                    d[i].data = s.data;\n                }\n                else\n                    s.data = d[i];\n                res.push(s);\n            }\n\n            return res;\n        }\n\n        function axisNumber(obj, coord) {\n            var a = obj[coord + \"axis\"];\n            if (typeof a == \"object\") // if we got a real axis, extract number\n                a = a.n;\n            if (typeof a != \"number\")\n                a = 1; // default to first axis\n            return a;\n        }\n\n        function allAxes() {\n            // return flat array without annoying null entries\n            return $.grep(xaxes.concat(yaxes), function (a) { return a; });\n        }\n\n        function canvasToAxisCoords(pos) {\n            // return an object with x/y corresponding to all used axes\n            var res = {}, i, axis;\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used)\n                    res[\"x\" + axis.n] = axis.c2p(pos.left);\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used)\n                    res[\"y\" + axis.n] = axis.c2p(pos.top);\n            }\n\n            if (res.x1 !== undefined)\n                res.x = res.x1;\n            if (res.y1 !== undefined)\n                res.y = res.y1;\n\n            return res;\n        }\n\n        function axisToCanvasCoords(pos) {\n            // get canvas coords from the first pair of x/y found in pos\n            var res = {}, i, axis, key;\n\n            for (i = 0; i < xaxes.length; ++i) {\n                axis = xaxes[i];\n                if (axis && axis.used) {\n                    key = \"x\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"x\";\n\n                    if (pos[key] != null) {\n                        res.left = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            for (i = 0; i < yaxes.length; ++i) {\n                axis = yaxes[i];\n                if (axis && axis.used) {\n                    key = \"y\" + axis.n;\n                    if (pos[key] == null && axis.n == 1)\n                        key = \"y\";\n\n                    if (pos[key] != null) {\n                        res.top = axis.p2c(pos[key]);\n                        break;\n                    }\n                }\n            }\n\n            return res;\n        }\n\n        function getOrCreateAxis(axes, number) {\n            if (!axes[number - 1])\n                axes[number - 1] = {\n                    n: number, // save the number for future reference\n                    direction: axes == xaxes ? \"x\" : \"y\",\n                    options: $.extend(true, {}, axes == xaxes ? options.xaxis : options.yaxis)\n                };\n\n            return axes[number - 1];\n        }\n\n        function fillInSeriesOptions() {\n\n            var neededColors = series.length, maxIndex = -1, i;\n\n            // Subtract the number of series that already have fixed colors or\n            // color indexes from the number that we still need to generate.\n\n            for (i = 0; i < series.length; ++i) {\n                var sc = series[i].color;\n                if (sc != null) {\n                    neededColors--;\n                    if (typeof sc == \"number\" && sc > maxIndex) {\n                        maxIndex = sc;\n                    }\n                }\n            }\n\n            // If any of the series have fixed color indexes, then we need to\n            // generate at least as many colors as the highest index.\n\n            if (neededColors <= maxIndex) {\n                neededColors = maxIndex + 1;\n            }\n\n            // Generate all the colors, using first the option colors and then\n            // variations on those colors once they're exhausted.\n\n            var c, colors = [], colorPool = options.colors,\n                colorPoolSize = colorPool.length, variation = 0;\n\n            for (i = 0; i < neededColors; i++) {\n\n                c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n\n                // Each time we exhaust the colors in the pool we adjust\n                // a scaling factor used to produce more variations on\n                // those colors. The factor alternates negative/positive\n                // to produce lighter/darker colors.\n\n                // Reset the variation after every few cycles, or else\n                // it will end up producing only white or black colors.\n\n                if (i % colorPoolSize == 0 && i) {\n                    if (variation >= 0) {\n                        if (variation < 0.5) {\n                            variation = -variation - 0.2;\n                        } else variation = 0;\n                    } else variation = -variation;\n                }\n\n                colors[i] = c.scale('rgb', 1 + variation);\n            }\n\n            // Finalize the series options, filling in their colors\n\n            var colori = 0, s;\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                // assign colors\n                if (s.color == null) {\n                    s.color = colors[colori].toString();\n                    ++colori;\n                }\n                else if (typeof s.color == \"number\")\n                    s.color = colors[s.color].toString();\n\n                // turn on lines automatically in case nothing is set\n                if (s.lines.show == null) {\n                    var v, show = true;\n                    for (v in s)\n                        if (s[v] && s[v].show) {\n                            show = false;\n                            break;\n                        }\n                    if (show)\n                        s.lines.show = true;\n                }\n\n                // If nothing was provided for lines.zero, default it to match\n                // lines.fill, since areas by default should extend to zero.\n\n                if (s.lines.zero == null) {\n                    s.lines.zero = !!s.lines.fill;\n                }\n\n                // setup axes\n                s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n                s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"));\n            }\n        }\n\n        function processData() {\n            var topSentry = Number.POSITIVE_INFINITY,\n                bottomSentry = Number.NEGATIVE_INFINITY,\n                fakeInfinity = Number.MAX_VALUE,\n                i, j, k, m, length,\n                s, points, ps, x, y, axis, val, f, p,\n                data, format;\n\n            function updateAxis(axis, min, max) {\n                if (min < axis.datamin && min != -fakeInfinity)\n                    axis.datamin = min;\n                if (max > axis.datamax && max != fakeInfinity)\n                    axis.datamax = max;\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                // init axis\n                axis.datamin = topSentry;\n                axis.datamax = bottomSentry;\n                axis.used = false;\n            });\n\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                s.datapoints = { points: [] };\n\n                executeHooks(hooks.processRawData, [ s, s.data, s.datapoints ]);\n            }\n\n            // first pass: clean and copy data\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                data = s.data;\n                format = s.datapoints.format;\n\n                if (!format) {\n                    format = [];\n                    // find out how to copy\n                    format.push({ x: true, number: true, required: true });\n                    format.push({ y: true, number: true, required: true });\n\n                    if (s.bars.show || (s.lines.show && s.lines.fill)) {\n                        var autoscale = !!((s.bars.show && s.bars.zero) || (s.lines.show && s.lines.zero));\n                        format.push({ y: true, number: true, required: false, defaultValue: 0, autoscale: autoscale });\n                        if (s.bars.horizontal) {\n                            delete format[format.length - 1].y;\n                            format[format.length - 1].x = true;\n                        }\n                    }\n\n                    s.datapoints.format = format;\n                }\n\n                if (s.datapoints.pointsize != null)\n                    continue; // already filled in\n\n                s.datapoints.pointsize = format.length;\n\n                ps = s.datapoints.pointsize;\n                points = s.datapoints.points;\n\n                var insertSteps = s.lines.show && s.lines.steps;\n                s.xaxis.used = s.yaxis.used = true;\n\n                for (j = k = 0; j < data.length; ++j, k += ps) {\n                    p = data[j];\n\n                    var nullify = p == null;\n                    if (!nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = p[m];\n                            f = format[m];\n\n                            if (f) {\n                                if (f.number && val != null) {\n                                    val = +val; // convert to number\n                                    if (isNaN(val))\n                                        val = null;\n                                    else if (val == Infinity)\n                                        val = fakeInfinity;\n                                    else if (val == -Infinity)\n                                        val = -fakeInfinity;\n                                }\n\n                                if (val == null) {\n                                    if (f.required)\n                                        nullify = true;\n\n                                    if (f.defaultValue != null)\n                                        val = f.defaultValue;\n                                }\n                            }\n\n                            points[k + m] = val;\n                        }\n                    }\n\n                    if (nullify) {\n                        for (m = 0; m < ps; ++m) {\n                            val = points[k + m];\n                            if (val != null) {\n                                f = format[m];\n                                // extract min/max info\n                                if (f.autoscale !== false) {\n                                    if (f.x) {\n                                        updateAxis(s.xaxis, val, val);\n                                    }\n                                    if (f.y) {\n                                        updateAxis(s.yaxis, val, val);\n                                    }\n                                }\n                            }\n                            points[k + m] = null;\n                        }\n                    }\n                    else {\n                        // a little bit of line specific stuff that\n                        // perhaps shouldn't be here, but lacking\n                        // better means...\n                        if (insertSteps && k > 0\n                            && points[k - ps] != null\n                            && points[k - ps] != points[k]\n                            && points[k - ps + 1] != points[k + 1]) {\n                            // copy the point to make room for a middle point\n                            for (m = 0; m < ps; ++m)\n                                points[k + ps + m] = points[k + m];\n\n                            // middle point has same y\n                            points[k + 1] = points[k - ps + 1];\n\n                            // we've added a point, better reflect that\n                            k += ps;\n                        }\n                    }\n                }\n            }\n\n            // give the hooks a chance to run\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n\n                executeHooks(hooks.processDatapoints, [ s, s.datapoints]);\n            }\n\n            // second pass: find datamax/datamin for auto-scaling\n            for (i = 0; i < series.length; ++i) {\n                s = series[i];\n                points = s.datapoints.points;\n                ps = s.datapoints.pointsize;\n                format = s.datapoints.format;\n\n                var xmin = topSentry, ymin = topSentry,\n                    xmax = bottomSentry, ymax = bottomSentry;\n\n                for (j = 0; j < points.length; j += ps) {\n                    if (points[j] == null)\n                        continue;\n\n                    for (m = 0; m < ps; ++m) {\n                        val = points[j + m];\n                        f = format[m];\n                        if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity)\n                            continue;\n\n                        if (f.x) {\n                            if (val < xmin)\n                                xmin = val;\n                            if (val > xmax)\n                                xmax = val;\n                        }\n                        if (f.y) {\n                            if (val < ymin)\n                                ymin = val;\n                            if (val > ymax)\n                                ymax = val;\n                        }\n                    }\n                }\n\n                if (s.bars.show) {\n                    // make sure we got room for the bar on the dancing floor\n                    var delta;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            delta = 0;\n                            break;\n                        case \"right\":\n                            delta = -s.bars.barWidth;\n                            break;\n                        default:\n                            delta = -s.bars.barWidth / 2;\n                    }\n\n                    if (s.bars.horizontal) {\n                        ymin += delta;\n                        ymax += delta + s.bars.barWidth;\n                    }\n                    else {\n                        xmin += delta;\n                        xmax += delta + s.bars.barWidth;\n                    }\n                }\n\n                updateAxis(s.xaxis, xmin, xmax);\n                updateAxis(s.yaxis, ymin, ymax);\n            }\n\n            $.each(allAxes(), function (_, axis) {\n                if (axis.datamin == topSentry)\n                    axis.datamin = null;\n                if (axis.datamax == bottomSentry)\n                    axis.datamax = null;\n            });\n        }\n\n        function setupCanvases() {\n\n            // Make sure the placeholder is clear of everything except canvases\n            // from a previous plot in this container that we'll try to re-use.\n\n            placeholder.css(\"padding\", 0) // padding messes up the positioning\n                .children().filter(function(){\n                    return !$(this).hasClass(\"flot-overlay\") && !$(this).hasClass('flot-base');\n                }).remove();\n\n            if (placeholder.css(\"position\") == 'static')\n                placeholder.css(\"position\", \"relative\"); // for positioning labels and overlay\n\n            surface = new Canvas(\"flot-base\", placeholder);\n            overlay = new Canvas(\"flot-overlay\", placeholder); // overlay canvas for interactive features\n\n            ctx = surface.context;\n            octx = overlay.context;\n\n            // define which element we're listening for events on\n            eventHolder = $(overlay.element).unbind();\n\n            // If we're re-using a plot object, shut down the old one\n\n            var existing = placeholder.data(\"plot\");\n\n            if (existing) {\n                existing.shutdown();\n                overlay.clear();\n            }\n\n            // save in case we get replotted\n            placeholder.data(\"plot\", plot);\n        }\n\n        function bindEvents() {\n            // bind events\n            if (options.grid.hoverable) {\n                eventHolder.mousemove(onMouseMove);\n\n                // Use bind, rather than .mouseleave, because we officially\n                // still support jQuery 1.2.6, which doesn't define a shortcut\n                // for mouseenter or mouseleave.  This was a bug/oversight that\n                // was fixed somewhere around 1.3.x.  We can return to using\n                // .mouseleave when we drop support for 1.2.6.\n\n                eventHolder.bind(\"mouseleave\", onMouseLeave);\n            }\n\n            if (options.grid.clickable)\n                eventHolder.click(onClick);\n\n            executeHooks(hooks.bindEvents, [eventHolder]);\n        }\n\n        function shutdown() {\n            if (redrawTimeout)\n                clearTimeout(redrawTimeout);\n\n            eventHolder.unbind(\"mousemove\", onMouseMove);\n            eventHolder.unbind(\"mouseleave\", onMouseLeave);\n            eventHolder.unbind(\"click\", onClick);\n\n            executeHooks(hooks.shutdown, [eventHolder]);\n        }\n\n        function setTransformationHelpers(axis) {\n            // set helper functions on the axis, assumes plot area\n            // has been computed already\n\n            function identity(x) { return x; }\n\n            var s, m, t = axis.options.transform || identity,\n                it = axis.options.inverseTransform;\n\n            // precompute how much the axis is scaling a point\n            // in canvas space\n            if (axis.direction == \"x\") {\n                s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n                m = Math.min(t(axis.max), t(axis.min));\n            }\n            else {\n                s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n                s = -s;\n                m = Math.max(t(axis.max), t(axis.min));\n            }\n\n            // data point to canvas coordinate\n            if (t == identity) // slight optimization\n                axis.p2c = function (p) { return (p - m) * s; };\n            else\n                axis.p2c = function (p) { return (t(p) - m) * s; };\n            // canvas coordinate to data point\n            if (!it)\n                axis.c2p = function (c) { return m + c / s; };\n            else\n                axis.c2p = function (c) { return it(m + c / s); };\n        }\n\n        function measureTickLabels(axis) {\n\n            var opts = axis.options,\n                ticks = axis.ticks || [],\n                labelWidth = opts.labelWidth || 0,\n                labelHeight = opts.labelHeight || 0,\n                maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n                legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                font = opts.font || \"flot-tick-label tickLabel\";\n\n            for (var i = 0; i < ticks.length; ++i) {\n\n                var t = ticks[i];\n\n                if (!t.label)\n                    continue;\n\n                var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n\n                labelWidth = Math.max(labelWidth, info.width);\n                labelHeight = Math.max(labelHeight, info.height);\n            }\n\n            axis.labelWidth = opts.labelWidth || labelWidth;\n            axis.labelHeight = opts.labelHeight || labelHeight;\n        }\n\n        function allocateAxisBoxFirstPhase(axis) {\n            // find the bounding box of the axis by looking at label\n            // widths/heights and ticks, make room by diminishing the\n            // plotOffset; this first phase only looks at one\n            // dimension per axis, the other dimension depends on the\n            // other axes so will have to wait\n\n            var lw = axis.labelWidth,\n                lh = axis.labelHeight,\n                pos = axis.options.position,\n                isXAxis = axis.direction === \"x\",\n                tickLength = axis.options.tickLength,\n                axisMargin = options.grid.axisMargin,\n                padding = options.grid.labelMargin,\n                innermost = true,\n                outermost = true,\n                first = true,\n                found = false;\n\n            // Determine the axis's position in its direction and on its side\n\n            $.each(isXAxis ? xaxes : yaxes, function(i, a) {\n                if (a && (a.show || a.reserveSpace)) {\n                    if (a === axis) {\n                        found = true;\n                    } else if (a.options.position === pos) {\n                        if (found) {\n                            outermost = false;\n                        } else {\n                            innermost = false;\n                        }\n                    }\n                    if (!found) {\n                        first = false;\n                    }\n                }\n            });\n\n            // The outermost axis on each side has no margin\n\n            if (outermost) {\n                axisMargin = 0;\n            }\n\n            // The ticks for the first axis in each direction stretch across\n\n            if (tickLength == null) {\n                tickLength = first ? \"full\" : 5;\n            }\n\n            if (!isNaN(+tickLength))\n                padding += +tickLength;\n\n            if (isXAxis) {\n                lh += padding;\n\n                if (pos == \"bottom\") {\n                    plotOffset.bottom += lh + axisMargin;\n                    axis.box = { top: surface.height - plotOffset.bottom, height: lh };\n                }\n                else {\n                    axis.box = { top: plotOffset.top + axisMargin, height: lh };\n                    plotOffset.top += lh + axisMargin;\n                }\n            }\n            else {\n                lw += padding;\n\n                if (pos == \"left\") {\n                    axis.box = { left: plotOffset.left + axisMargin, width: lw };\n                    plotOffset.left += lw + axisMargin;\n                }\n                else {\n                    plotOffset.right += lw + axisMargin;\n                    axis.box = { left: surface.width - plotOffset.right, width: lw };\n                }\n            }\n\n             // save for future reference\n            axis.position = pos;\n            axis.tickLength = tickLength;\n            axis.box.padding = padding;\n            axis.innermost = innermost;\n        }\n\n        function allocateAxisBoxSecondPhase(axis) {\n            // now that all axis boxes have been placed in one\n            // dimension, we can set the remaining dimension coordinates\n            if (axis.direction == \"x\") {\n                axis.box.left = plotOffset.left - axis.labelWidth / 2;\n                axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth;\n            }\n            else {\n                axis.box.top = plotOffset.top - axis.labelHeight / 2;\n                axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight;\n            }\n        }\n\n        function adjustLayoutForThingsStickingOut() {\n            // possibly adjust plot offset to ensure everything stays\n            // inside the canvas and isn't clipped off\n\n            var minMargin = options.grid.minBorderMargin,\n                axis, i;\n\n            // check stuff from the plot (FIXME: this should just read\n            // a value from the series, otherwise it's impossible to\n            // customize)\n            if (minMargin == null) {\n                minMargin = 0;\n                for (i = 0; i < series.length; ++i)\n                    minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth/2));\n            }\n\n            var margins = {\n                left: minMargin,\n                right: minMargin,\n                top: minMargin,\n                bottom: minMargin\n            };\n\n            // check axis labels, note we don't check the actual\n            // labels but instead use the overall width/height to not\n            // jump as much around with replots\n            $.each(allAxes(), function (_, axis) {\n                if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n                    if (axis.direction === \"x\") {\n                        margins.left = Math.max(margins.left, axis.labelWidth / 2);\n                        margins.right = Math.max(margins.right, axis.labelWidth / 2);\n                    } else {\n                        margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n                        margins.top = Math.max(margins.top, axis.labelHeight / 2);\n                    }\n                }\n            });\n\n            plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n            plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n            plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n            plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom));\n        }\n\n        function setupGrid() {\n            var i, axes = allAxes(), showGrid = options.grid.show;\n\n            // Initialize the plot's offset from the edge of the canvas\n\n            for (var a in plotOffset) {\n                var margin = options.grid.margin || 0;\n                plotOffset[a] = typeof margin == \"number\" ? margin : margin[a] || 0;\n            }\n\n            executeHooks(hooks.processOffset, [plotOffset]);\n\n            // If the grid is visible, add its border width to the offset\n\n            for (var a in plotOffset) {\n                if(typeof(options.grid.borderWidth) == \"object\") {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0;\n                }\n                else {\n                    plotOffset[a] += showGrid ? options.grid.borderWidth : 0;\n                }\n            }\n\n            $.each(axes, function (_, axis) {\n                var axisOpts = axis.options;\n                axis.show = axisOpts.show == null ? axis.used : axisOpts.show;\n                axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show : axisOpts.reserveSpace;\n                setRange(axis);\n            });\n\n            if (showGrid) {\n\n                var allocatedAxes = $.grep(axes, function (axis) {\n                    return axis.show || axis.reserveSpace;\n                });\n\n                $.each(allocatedAxes, function (_, axis) {\n                    // make the ticks\n                    setupTickGeneration(axis);\n                    setTicks(axis);\n                    snapRangeToTicks(axis, axis.ticks);\n                    // find labelWidth/Height for axis\n                    measureTickLabels(axis);\n                });\n\n                // with all dimensions calculated, we can compute the\n                // axis bounding boxes, start from the outside\n                // (reverse order)\n                for (i = allocatedAxes.length - 1; i >= 0; --i)\n                    allocateAxisBoxFirstPhase(allocatedAxes[i]);\n\n                // make sure we've got enough space for things that\n                // might stick out\n                adjustLayoutForThingsStickingOut();\n\n                $.each(allocatedAxes, function (_, axis) {\n                    allocateAxisBoxSecondPhase(axis);\n                });\n            }\n\n            plotWidth = surface.width - plotOffset.left - plotOffset.right;\n            plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n\n            // now we got the proper plot dimensions, we can compute the scaling\n            $.each(axes, function (_, axis) {\n                setTransformationHelpers(axis);\n            });\n\n            if (showGrid) {\n                drawAxisLabels();\n            }\n\n            insertLegend();\n        }\n\n        function setRange(axis) {\n            var opts = axis.options,\n                min = +(opts.min != null ? opts.min : axis.datamin),\n                max = +(opts.max != null ? opts.max : axis.datamax),\n                delta = max - min;\n\n            if (delta == 0.0) {\n                // degenerate case\n                var widen = max == 0 ? 1 : 0.01;\n\n                if (opts.min == null)\n                    min -= widen;\n                // always widen max if we couldn't widen min to ensure we\n                // don't fall into min == max which doesn't work\n                if (opts.max == null || opts.min != null)\n                    max += widen;\n            }\n            else {\n                // consider autoscaling\n                var margin = opts.autoscaleMargin;\n                if (margin != null) {\n                    if (opts.min == null) {\n                        min -= delta * margin;\n                        // make sure we don't go below zero if all values\n                        // are positive\n                        if (min < 0 && axis.datamin != null && axis.datamin >= 0)\n                            min = 0;\n                    }\n                    if (opts.max == null) {\n                        max += delta * margin;\n                        if (max > 0 && axis.datamax != null && axis.datamax <= 0)\n                            max = 0;\n                    }\n                }\n            }\n            axis.min = min;\n            axis.max = max;\n        }\n\n        function setupTickGeneration(axis) {\n            var opts = axis.options;\n\n            // estimate number of ticks\n            var noTicks;\n            if (typeof opts.ticks == \"number\" && opts.ticks > 0)\n                noTicks = opts.ticks;\n            else\n                // heuristic based on the model a*sqrt(x) fitted to\n                // some data points that seemed reasonable\n                noTicks = 0.3 * Math.sqrt(axis.direction == \"x\" ? surface.width : surface.height);\n\n            var delta = (axis.max - axis.min) / noTicks,\n                dec = -Math.floor(Math.log(delta) / Math.LN10),\n                maxDec = opts.tickDecimals;\n\n            if (maxDec != null && dec > maxDec) {\n                dec = maxDec;\n            }\n\n            var magn = Math.pow(10, -dec),\n                norm = delta / magn, // norm is between 1.0 and 10.0\n                size;\n\n            if (norm < 1.5) {\n                size = 1;\n            } else if (norm < 3) {\n                size = 2;\n                // special case for 2.5, requires an extra decimal\n                if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n                    size = 2.5;\n                    ++dec;\n                }\n            } else if (norm < 7.5) {\n                size = 5;\n            } else {\n                size = 10;\n            }\n\n            size *= magn;\n\n            if (opts.minTickSize != null && size < opts.minTickSize) {\n                size = opts.minTickSize;\n            }\n\n            axis.delta = delta;\n            axis.tickDecimals = Math.max(0, maxDec != null ? maxDec : dec);\n            axis.tickSize = opts.tickSize || size;\n\n            // Time mode was moved to a plug-in in 0.8, and since so many people use it\n            // we'll add an especially friendly reminder to make sure they included it.\n\n            if (opts.mode == \"time\" && !axis.tickGenerator) {\n                throw new Error(\"Time mode requires the flot.time plugin.\");\n            }\n\n            // Flot supports base-10 axes; any other mode else is handled by a plug-in,\n            // like flot.time.js.\n\n            if (!axis.tickGenerator) {\n\n                axis.tickGenerator = function (axis) {\n\n                    var ticks = [],\n                        start = floorInBase(axis.min, axis.tickSize),\n                        i = 0,\n                        v = Number.NaN,\n                        prev;\n\n                    do {\n                        prev = v;\n                        v = start + i * axis.tickSize;\n                        ticks.push(v);\n                        ++i;\n                    } while (v < axis.max && v != prev);\n                    return ticks;\n                };\n\n\t\t\t\taxis.tickFormatter = function (value, axis) {\n\n\t\t\t\t\tvar factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n\t\t\t\t\tvar formatted = \"\" + Math.round(value * factor) / factor;\n\n\t\t\t\t\t// If tickDecimals was specified, ensure that we have exactly that\n\t\t\t\t\t// much precision; otherwise default to the value's own precision.\n\n\t\t\t\t\tif (axis.tickDecimals != null) {\n\t\t\t\t\t\tvar decimal = formatted.indexOf(\".\");\n\t\t\t\t\t\tvar precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n\t\t\t\t\t\tif (precision < axis.tickDecimals) {\n\t\t\t\t\t\t\treturn (precision ? formatted : formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n                    return formatted;\n                };\n            }\n\n            if ($.isFunction(opts.tickFormatter))\n                axis.tickFormatter = function (v, axis) { return \"\" + opts.tickFormatter(v, axis); };\n\n            if (opts.alignTicksWithAxis != null) {\n                var otherAxis = (axis.direction == \"x\" ? xaxes : yaxes)[opts.alignTicksWithAxis - 1];\n                if (otherAxis && otherAxis.used && otherAxis != axis) {\n                    // consider snapping min/max to outermost nice ticks\n                    var niceTicks = axis.tickGenerator(axis);\n                    if (niceTicks.length > 0) {\n                        if (opts.min == null)\n                            axis.min = Math.min(axis.min, niceTicks[0]);\n                        if (opts.max == null && niceTicks.length > 1)\n                            axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1]);\n                    }\n\n                    axis.tickGenerator = function (axis) {\n                        // copy ticks, scaled to this axis\n                        var ticks = [], v, i;\n                        for (i = 0; i < otherAxis.ticks.length; ++i) {\n                            v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n                            v = axis.min + v * (axis.max - axis.min);\n                            ticks.push(v);\n                        }\n                        return ticks;\n                    };\n\n                    // we might need an extra decimal since forced\n                    // ticks don't necessarily fit naturally\n                    if (!axis.mode && opts.tickDecimals == null) {\n                        var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n                            ts = axis.tickGenerator(axis);\n\n                        // only proceed if the tick interval rounded\n                        // with an extra decimal doesn't give us a\n                        // zero at end\n                        if (!(ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec))))\n                            axis.tickDecimals = extraDec;\n                    }\n                }\n            }\n        }\n\n        function setTicks(axis) {\n            var oticks = axis.options.ticks, ticks = [];\n            if (oticks == null || (typeof oticks == \"number\" && oticks > 0))\n                ticks = axis.tickGenerator(axis);\n            else if (oticks) {\n                if ($.isFunction(oticks))\n                    // generate the ticks\n                    ticks = oticks(axis);\n                else\n                    ticks = oticks;\n            }\n\n            // clean up/labelify the supplied ticks, copy them over\n            var i, v;\n            axis.ticks = [];\n            for (i = 0; i < ticks.length; ++i) {\n                var label = null;\n                var t = ticks[i];\n                if (typeof t == \"object\") {\n                    v = +t[0];\n                    if (t.length > 1)\n                        label = t[1];\n                }\n                else\n                    v = +t;\n                if (label == null)\n                    label = axis.tickFormatter(v, axis);\n                if (!isNaN(v))\n                    axis.ticks.push({ v: v, label: label });\n            }\n        }\n\n        function snapRangeToTicks(axis, ticks) {\n            if (axis.options.autoscaleMargin && ticks.length > 0) {\n                // snap to ticks\n                if (axis.options.min == null)\n                    axis.min = Math.min(axis.min, ticks[0].v);\n                if (axis.options.max == null && ticks.length > 1)\n                    axis.max = Math.max(axis.max, ticks[ticks.length - 1].v);\n            }\n        }\n\n        function draw() {\n\n            surface.clear();\n\n            executeHooks(hooks.drawBackground, [ctx]);\n\n            var grid = options.grid;\n\n            // draw background, if any\n            if (grid.show && grid.backgroundColor)\n                drawBackground();\n\n            if (grid.show && !grid.aboveData) {\n                drawGrid();\n            }\n\n            for (var i = 0; i < series.length; ++i) {\n                executeHooks(hooks.drawSeries, [ctx, series[i]]);\n                drawSeries(series[i]);\n            }\n\n            executeHooks(hooks.draw, [ctx]);\n\n            if (grid.show && grid.aboveData) {\n                drawGrid();\n            }\n\n            surface.render();\n\n            // A draw implies that either the axes or data have changed, so we\n            // should probably update the overlay highlights as well.\n\n            triggerRedrawOverlay();\n        }\n\n        function extractRange(ranges, coord) {\n            var axis, from, to, key, axes = allAxes();\n\n            for (var i = 0; i < axes.length; ++i) {\n                axis = axes[i];\n                if (axis.direction == coord) {\n                    key = coord + axis.n + \"axis\";\n                    if (!ranges[key] && axis.n == 1)\n                        key = coord + \"axis\"; // support x1axis as xaxis\n                    if (ranges[key]) {\n                        from = ranges[key].from;\n                        to = ranges[key].to;\n                        break;\n                    }\n                }\n            }\n\n            // backwards-compat stuff - to be removed in future\n            if (!ranges[key]) {\n                axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n                from = ranges[coord + \"1\"];\n                to = ranges[coord + \"2\"];\n            }\n\n            // auto-reverse as an added bonus\n            if (from != null && to != null && from > to) {\n                var tmp = from;\n                from = to;\n                to = tmp;\n            }\n\n            return { from: from, to: to, axis: axis };\n        }\n\n        function drawBackground() {\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n            ctx.fillRect(0, 0, plotWidth, plotHeight);\n            ctx.restore();\n        }\n\n        function drawGrid() {\n            var i, axes, bw, bc;\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // draw markings\n            var markings = options.grid.markings;\n            if (markings) {\n                if ($.isFunction(markings)) {\n                    axes = plot.getAxes();\n                    // xmin etc. is backwards compatibility, to be\n                    // removed in the future\n                    axes.xmin = axes.xaxis.min;\n                    axes.xmax = axes.xaxis.max;\n                    axes.ymin = axes.yaxis.min;\n                    axes.ymax = axes.yaxis.max;\n\n                    markings = markings(axes);\n                }\n\n                for (i = 0; i < markings.length; ++i) {\n                    var m = markings[i],\n                        xrange = extractRange(m, \"x\"),\n                        yrange = extractRange(m, \"y\");\n\n                    // fill in missing\n                    if (xrange.from == null)\n                        xrange.from = xrange.axis.min;\n                    if (xrange.to == null)\n                        xrange.to = xrange.axis.max;\n                    if (yrange.from == null)\n                        yrange.from = yrange.axis.min;\n                    if (yrange.to == null)\n                        yrange.to = yrange.axis.max;\n\n                    // clip\n                    if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max ||\n                        yrange.to < yrange.axis.min || yrange.from > yrange.axis.max)\n                        continue;\n\n                    xrange.from = Math.max(xrange.from, xrange.axis.min);\n                    xrange.to = Math.min(xrange.to, xrange.axis.max);\n                    yrange.from = Math.max(yrange.from, yrange.axis.min);\n                    yrange.to = Math.min(yrange.to, yrange.axis.max);\n\n                    var xequal = xrange.from === xrange.to,\n                        yequal = yrange.from === yrange.to;\n\n                    if (xequal && yequal) {\n                        continue;\n                    }\n\n                    // then draw\n                    xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n                    xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n                    yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n                    yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n\n                    if (xequal || yequal) {\n                        var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n                            subPixel = lineWidth % 2 ? 0.5 : 0;\n                        ctx.beginPath();\n                        ctx.strokeStyle = m.color || options.grid.markingsColor;\n                        ctx.lineWidth = lineWidth;\n                        if (xequal) {\n                            ctx.moveTo(xrange.to + subPixel, yrange.from);\n                            ctx.lineTo(xrange.to + subPixel, yrange.to);\n                        } else {\n                            ctx.moveTo(xrange.from, yrange.to + subPixel);\n                            ctx.lineTo(xrange.to, yrange.to + subPixel);                            \n                        }\n                        ctx.stroke();\n                    } else {\n                        ctx.fillStyle = m.color || options.grid.markingsColor;\n                        ctx.fillRect(xrange.from, yrange.to,\n                                     xrange.to - xrange.from,\n                                     yrange.from - yrange.to);\n                    }\n                }\n            }\n\n            // draw the ticks\n            axes = allAxes();\n            bw = options.grid.borderWidth;\n\n            for (var j = 0; j < axes.length; ++j) {\n                var axis = axes[j], box = axis.box,\n                    t = axis.tickLength, x, y, xoff, yoff;\n                if (!axis.show || axis.ticks.length == 0)\n                    continue;\n\n                ctx.lineWidth = 1;\n\n                // find the edges\n                if (axis.direction == \"x\") {\n                    x = 0;\n                    if (t == \"full\")\n                        y = (axis.position == \"top\" ? 0 : plotHeight);\n                    else\n                        y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height : 0);\n                }\n                else {\n                    y = 0;\n                    if (t == \"full\")\n                        x = (axis.position == \"left\" ? 0 : plotWidth);\n                    else\n                        x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width : 0);\n                }\n\n                // draw tick bar\n                if (!axis.innermost) {\n                    ctx.strokeStyle = axis.options.color;\n                    ctx.beginPath();\n                    xoff = yoff = 0;\n                    if (axis.direction == \"x\")\n                        xoff = plotWidth + 1;\n                    else\n                        yoff = plotHeight + 1;\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\") {\n                            y = Math.floor(y) + 0.5;\n                        } else {\n                            x = Math.floor(x) + 0.5;\n                        }\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                    ctx.stroke();\n                }\n\n                // draw ticks\n\n                ctx.strokeStyle = axis.options.tickColor;\n\n                ctx.beginPath();\n                for (i = 0; i < axis.ticks.length; ++i) {\n                    var v = axis.ticks[i].v;\n\n                    xoff = yoff = 0;\n\n                    if (isNaN(v) || v < axis.min || v > axis.max\n                        // skip those lying on the axes if we got a border\n                        || (t == \"full\"\n                            && ((typeof bw == \"object\" && bw[axis.position] > 0) || bw > 0)\n                            && (v == axis.min || v == axis.max)))\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        x = axis.p2c(v);\n                        yoff = t == \"full\" ? -plotHeight : t;\n\n                        if (axis.position == \"top\")\n                            yoff = -yoff;\n                    }\n                    else {\n                        y = axis.p2c(v);\n                        xoff = t == \"full\" ? -plotWidth : t;\n\n                        if (axis.position == \"left\")\n                            xoff = -xoff;\n                    }\n\n                    if (ctx.lineWidth == 1) {\n                        if (axis.direction == \"x\")\n                            x = Math.floor(x) + 0.5;\n                        else\n                            y = Math.floor(y) + 0.5;\n                    }\n\n                    ctx.moveTo(x, y);\n                    ctx.lineTo(x + xoff, y + yoff);\n                }\n\n                ctx.stroke();\n            }\n\n\n            // draw border\n            if (bw) {\n                // If either borderWidth or borderColor is an object, then draw the border\n                // line by line instead of as one rectangle\n                bc = options.grid.borderColor;\n                if(typeof bw == \"object\" || typeof bc == \"object\") {\n                    if (typeof bw !== \"object\") {\n                        bw = {top: bw, right: bw, bottom: bw, left: bw};\n                    }\n                    if (typeof bc !== \"object\") {\n                        bc = {top: bc, right: bc, bottom: bc, left: bc};\n                    }\n\n                    if (bw.top > 0) {\n                        ctx.strokeStyle = bc.top;\n                        ctx.lineWidth = bw.top;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left, 0 - bw.top/2);\n                        ctx.lineTo(plotWidth, 0 - bw.top/2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.right > 0) {\n                        ctx.strokeStyle = bc.right;\n                        ctx.lineWidth = bw.right;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n                        ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n                        ctx.stroke();\n                    }\n\n                    if (bw.bottom > 0) {\n                        ctx.strokeStyle = bc.bottom;\n                        ctx.lineWidth = bw.bottom;\n                        ctx.beginPath();\n                        ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n                        ctx.lineTo(0, plotHeight + bw.bottom / 2);\n                        ctx.stroke();\n                    }\n\n                    if (bw.left > 0) {\n                        ctx.strokeStyle = bc.left;\n                        ctx.lineWidth = bw.left;\n                        ctx.beginPath();\n                        ctx.moveTo(0 - bw.left/2, plotHeight + bw.bottom);\n                        ctx.lineTo(0- bw.left/2, 0);\n                        ctx.stroke();\n                    }\n                }\n                else {\n                    ctx.lineWidth = bw;\n                    ctx.strokeStyle = options.grid.borderColor;\n                    ctx.strokeRect(-bw/2, -bw/2, plotWidth + bw, plotHeight + bw);\n                }\n            }\n\n            ctx.restore();\n        }\n\n        function drawAxisLabels() {\n\n            $.each(allAxes(), function (_, axis) {\n                var box = axis.box,\n                    legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n                    layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n                    font = axis.options.font || \"flot-tick-label tickLabel\",\n                    tick, x, y, halign, valign;\n\n                // Remove text before checking for axis.show and ticks.length;\n                // otherwise plugins, like flot-tickrotor, that draw their own\n                // tick labels will end up with both theirs and the defaults.\n\n                surface.removeText(layer);\n\n                if (!axis.show || axis.ticks.length == 0)\n                    return;\n\n                for (var i = 0; i < axis.ticks.length; ++i) {\n\n                    tick = axis.ticks[i];\n                    if (!tick.label || tick.v < axis.min || tick.v > axis.max)\n                        continue;\n\n                    if (axis.direction == \"x\") {\n                        halign = \"center\";\n                        x = plotOffset.left + axis.p2c(tick.v);\n                        if (axis.position == \"bottom\") {\n                            y = box.top + box.padding;\n                        } else {\n                            y = box.top + box.height - box.padding;\n                            valign = \"bottom\";\n                        }\n                    } else {\n                        valign = \"middle\";\n                        y = plotOffset.top + axis.p2c(tick.v);\n                        if (axis.position == \"left\") {\n                            x = box.left + box.width - box.padding;\n                            halign = \"right\";\n                        } else {\n                            x = box.left + box.padding;\n                        }\n                    }\n\n                    surface.addText(layer, x, y, tick.label, font, null, null, halign, valign);\n                }\n            });\n        }\n\n        function drawSeries(series) {\n            if (series.lines.show)\n                drawSeriesLines(series);\n            if (series.bars.show)\n                drawSeriesBars(series);\n            if (series.points.show)\n                drawSeriesPoints(series);\n        }\n\n        function drawSeriesLines(series) {\n            function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    prevx = null, prevy = null;\n\n                ctx.beginPath();\n                for (var i = ps; i < points.length; i += ps) {\n                    var x1 = points[i - ps], y1 = points[i - ps + 1],\n                        x2 = points[i], y2 = points[i + 1];\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min) {\n                        if (y2 < axisy.min)\n                            continue;   // line segment is outside\n                        // compute new intersection point\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min) {\n                        if (y1 < axisy.min)\n                            continue;\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max) {\n                        if (y2 > axisy.max)\n                            continue;\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max) {\n                        if (y1 > axisy.max)\n                            continue;\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (x1 != prevx || y1 != prevy)\n                        ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n\n                    prevx = x2;\n                    prevy = y2;\n                    ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset);\n                }\n                ctx.stroke();\n            }\n\n            function plotLineArea(datapoints, axisx, axisy) {\n                var points = datapoints.points,\n                    ps = datapoints.pointsize,\n                    bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n                    i = 0, top, areaOpen = false,\n                    ypos = 1, segmentStart = 0, segmentEnd = 0;\n\n                // we process each segment in two turns, first forward\n                // direction to sketch out top, then once we hit the\n                // end we go backwards to sketch the bottom\n                while (true) {\n                    if (ps > 0 && i > points.length + ps)\n                        break;\n\n                    i += ps; // ps is negative if going backwards\n\n                    var x1 = points[i - ps],\n                        y1 = points[i - ps + ypos],\n                        x2 = points[i], y2 = points[i + ypos];\n\n                    if (areaOpen) {\n                        if (ps > 0 && x1 != null && x2 == null) {\n                            // at turning point\n                            segmentEnd = i;\n                            ps = -ps;\n                            ypos = 2;\n                            continue;\n                        }\n\n                        if (ps < 0 && i == segmentStart + ps) {\n                            // done with the reverse sweep\n                            ctx.fill();\n                            areaOpen = false;\n                            ps = -ps;\n                            ypos = 1;\n                            i = segmentStart = segmentEnd + ps;\n                            continue;\n                        }\n                    }\n\n                    if (x1 == null || x2 == null)\n                        continue;\n\n                    // clip x values\n\n                    // clip with xmin\n                    if (x1 <= x2 && x1 < axisx.min) {\n                        if (x2 < axisx.min)\n                            continue;\n                        y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.min;\n                    }\n                    else if (x2 <= x1 && x2 < axisx.min) {\n                        if (x1 < axisx.min)\n                            continue;\n                        y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.min;\n                    }\n\n                    // clip with xmax\n                    if (x1 >= x2 && x1 > axisx.max) {\n                        if (x2 > axisx.max)\n                            continue;\n                        y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x1 = axisx.max;\n                    }\n                    else if (x2 >= x1 && x2 > axisx.max) {\n                        if (x1 > axisx.max)\n                            continue;\n                        y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n                        x2 = axisx.max;\n                    }\n\n                    if (!areaOpen) {\n                        // open area\n                        ctx.beginPath();\n                        ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n                        areaOpen = true;\n                    }\n\n                    // now first check the case where both is outside\n                    if (y1 >= axisy.max && y2 >= axisy.max) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n                        continue;\n                    }\n                    else if (y1 <= axisy.min && y2 <= axisy.min) {\n                        ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n                        continue;\n                    }\n\n                    // else it's a bit more complicated, there might\n                    // be a flat maxed out rectangle first, then a\n                    // triangular cutout or reverse; to find these\n                    // keep track of the current x values\n                    var x1old = x1, x2old = x2;\n\n                    // clip the y values, without shortcutting, we\n                    // go through all cases in turn\n\n                    // clip with ymin\n                    if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n                        x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.min;\n                    }\n                    else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n                        x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.min;\n                    }\n\n                    // clip with ymax\n                    if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n                        x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y1 = axisy.max;\n                    }\n                    else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n                        x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n                        y2 = axisy.max;\n                    }\n\n                    // if the x value was changed we got a rectangle\n                    // to fill\n                    if (x1 != x1old) {\n                        ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1));\n                        // it goes to (x1, y1), but we fill that below\n                    }\n\n                    // fill triangular section, this sometimes result\n                    // in redundant points if (x1, y1) hasn't changed\n                    // from previous line to, but we just ignore that\n                    ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n                    ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n\n                    // fill the other rectangle if it's there\n                    if (x2 != x2old) {\n                        ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n                        ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2));\n                    }\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n            ctx.lineJoin = \"round\";\n\n            var lw = series.lines.lineWidth,\n                sw = series.shadowSize;\n            // FIXME: consider another form of shadow when filling is turned on\n            if (lw > 0 && sw > 0) {\n                // draw shadow as a thick and thin line with transparency\n                ctx.lineWidth = sw;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                // position shadow at angle from the mid of line\n                var angle = Math.PI/18;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/2), Math.cos(angle) * (lw/2 + sw/2), series.xaxis, series.yaxis);\n                ctx.lineWidth = sw/2;\n                plotLine(series.datapoints, Math.sin(angle) * (lw/2 + sw/4), Math.cos(angle) * (lw/2 + sw/4), series.xaxis, series.yaxis);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n            if (fillStyle) {\n                ctx.fillStyle = fillStyle;\n                plotLineArea(series.datapoints, series.xaxis, series.yaxis);\n            }\n\n            if (lw > 0)\n                plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function drawSeriesPoints(series) {\n            function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    var x = points[i], y = points[i + 1];\n                    if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                        continue;\n\n                    ctx.beginPath();\n                    x = axisx.p2c(x);\n                    y = axisy.p2c(y) + offset;\n                    if (symbol == \"circle\")\n                        ctx.arc(x, y, radius, 0, shadow ? Math.PI : Math.PI * 2, false);\n                    else\n                        symbol(ctx, x, y, radius, shadow);\n                    ctx.closePath();\n\n                    if (fillStyle) {\n                        ctx.fillStyle = fillStyle;\n                        ctx.fill();\n                    }\n                    ctx.stroke();\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            var lw = series.points.lineWidth,\n                sw = series.shadowSize,\n                radius = series.points.radius,\n                symbol = series.points.symbol;\n\n            // If the user sets the line width to 0, we change it to a very \n            // small value. A line width of 0 seems to force the default of 1.\n            // Doing the conditional here allows the shadow setting to still be \n            // optional even with a lineWidth of 0.\n\n            if( lw == 0 )\n                lw = 0.0001;\n\n            if (lw > 0 && sw > 0) {\n                // draw shadow in two steps\n                var w = sw / 2;\n                ctx.lineWidth = w;\n                ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n                plotPoints(series.datapoints, radius, null, w + w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n\n                ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n                plotPoints(series.datapoints, radius, null, w/2, true,\n                           series.xaxis, series.yaxis, symbol);\n            }\n\n            ctx.lineWidth = lw;\n            ctx.strokeStyle = series.color;\n            plotPoints(series.datapoints, radius,\n                       getFillStyle(series.points, series.color), 0, false,\n                       series.xaxis, series.yaxis, symbol);\n            ctx.restore();\n        }\n\n        function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n            var left, right, bottom, top,\n                drawLeft, drawRight, drawTop, drawBottom,\n                tmp;\n\n            // in horizontal mode, we start the bar from the left\n            // instead of from the bottom so it appears to be\n            // horizontal rather than vertical\n            if (horizontal) {\n                drawBottom = drawRight = drawTop = true;\n                drawLeft = false;\n                left = b;\n                right = x;\n                top = y + barLeft;\n                bottom = y + barRight;\n\n                // account for negative bars\n                if (right < left) {\n                    tmp = right;\n                    right = left;\n                    left = tmp;\n                    drawLeft = true;\n                    drawRight = false;\n                }\n            }\n            else {\n                drawLeft = drawRight = drawTop = true;\n                drawBottom = false;\n                left = x + barLeft;\n                right = x + barRight;\n                bottom = b;\n                top = y;\n\n                // account for negative bars\n                if (top < bottom) {\n                    tmp = top;\n                    top = bottom;\n                    bottom = tmp;\n                    drawBottom = true;\n                    drawTop = false;\n                }\n            }\n\n            // clip\n            if (right < axisx.min || left > axisx.max ||\n                top < axisy.min || bottom > axisy.max)\n                return;\n\n            if (left < axisx.min) {\n                left = axisx.min;\n                drawLeft = false;\n            }\n\n            if (right > axisx.max) {\n                right = axisx.max;\n                drawRight = false;\n            }\n\n            if (bottom < axisy.min) {\n                bottom = axisy.min;\n                drawBottom = false;\n            }\n\n            if (top > axisy.max) {\n                top = axisy.max;\n                drawTop = false;\n            }\n\n            left = axisx.p2c(left);\n            bottom = axisy.p2c(bottom);\n            right = axisx.p2c(right);\n            top = axisy.p2c(top);\n\n            // fill the bar\n            if (fillStyleCallback) {\n                c.fillStyle = fillStyleCallback(bottom, top);\n                c.fillRect(left, top, right - left, bottom - top)\n            }\n\n            // draw outline\n            if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n                c.beginPath();\n\n                // FIXME: inline moveTo is buggy with excanvas\n                c.moveTo(left, bottom);\n                if (drawLeft)\n                    c.lineTo(left, top);\n                else\n                    c.moveTo(left, top);\n                if (drawTop)\n                    c.lineTo(right, top);\n                else\n                    c.moveTo(right, top);\n                if (drawRight)\n                    c.lineTo(right, bottom);\n                else\n                    c.moveTo(right, bottom);\n                if (drawBottom)\n                    c.lineTo(left, bottom);\n                else\n                    c.moveTo(left, bottom);\n                c.stroke();\n            }\n        }\n\n        function drawSeriesBars(series) {\n            function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n                var points = datapoints.points, ps = datapoints.pointsize;\n\n                for (var i = 0; i < points.length; i += ps) {\n                    if (points[i] == null)\n                        continue;\n                    drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth);\n                }\n            }\n\n            ctx.save();\n            ctx.translate(plotOffset.left, plotOffset.top);\n\n            // FIXME: figure out a way to add shadows (for instance along the right edge)\n            ctx.lineWidth = series.bars.lineWidth;\n            ctx.strokeStyle = series.color;\n\n            var barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            var fillStyleCallback = series.bars.fill ? function (bottom, top) { return getFillStyle(series.bars, series.color, bottom, top); } : null;\n            plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n            ctx.restore();\n        }\n\n        function getFillStyle(filloptions, seriesColor, bottom, top) {\n            var fill = filloptions.fill;\n            if (!fill)\n                return null;\n\n            if (filloptions.fillColor)\n                return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n\n            var c = $.color.parse(seriesColor);\n            c.a = typeof fill == \"number\" ? fill : 0.4;\n            c.normalize();\n            return c.toString();\n        }\n\n        function insertLegend() {\n\n            if (options.legend.container != null) {\n                $(options.legend.container).html(\"\");\n            } else {\n                placeholder.find(\".legend\").remove();\n            }\n\n            if (!options.legend.show) {\n                return;\n            }\n\n            var fragments = [], entries = [], rowStarted = false,\n                lf = options.legend.labelFormatter, s, label;\n\n            // Build a list of legend entries, with each having a label and a color\n\n            for (var i = 0; i < series.length; ++i) {\n                s = series[i];\n                if (s.label) {\n                    label = lf ? lf(s.label, s) : s.label;\n                    if (label) {\n                        entries.push({\n                            label: label,\n                            color: s.color\n                        });\n                    }\n                }\n            }\n\n            // Sort the legend using either the default or a custom comparator\n\n            if (options.legend.sorted) {\n                if ($.isFunction(options.legend.sorted)) {\n                    entries.sort(options.legend.sorted);\n                } else if (options.legend.sorted == \"reverse\") {\n                \tentries.reverse();\n                } else {\n                    var ascending = options.legend.sorted != \"descending\";\n                    entries.sort(function(a, b) {\n                        return a.label == b.label ? 0 : (\n                            (a.label < b.label) != ascending ? 1 : -1   // Logical XOR\n                        );\n                    });\n                }\n            }\n\n            // Generate markup for the list of entries, in their final order\n\n            for (var i = 0; i < entries.length; ++i) {\n\n                var entry = entries[i];\n\n                if (i % options.legend.noColumns == 0) {\n                    if (rowStarted)\n                        fragments.push('</tr>');\n                    fragments.push('<tr>');\n                    rowStarted = true;\n                }\n\n                fragments.push(\n                    '<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' +\n                    '<td class=\"legendLabel\">' + entry.label + '</td>'\n                );\n            }\n\n            if (rowStarted)\n                fragments.push('</tr>');\n\n            if (fragments.length == 0)\n                return;\n\n            var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + '</table>';\n            if (options.legend.container != null)\n                $(options.legend.container).html(table);\n            else {\n                var pos = \"\",\n                    p = options.legend.position,\n                    m = options.legend.margin;\n                if (m[0] == null)\n                    m = [m, m];\n                if (p.charAt(0) == \"n\")\n                    pos += 'top:' + (m[1] + plotOffset.top) + 'px;';\n                else if (p.charAt(0) == \"s\")\n                    pos += 'bottom:' + (m[1] + plotOffset.bottom) + 'px;';\n                if (p.charAt(1) == \"e\")\n                    pos += 'right:' + (m[0] + plotOffset.right) + 'px;';\n                else if (p.charAt(1) == \"w\")\n                    pos += 'left:' + (m[0] + plotOffset.left) + 'px;';\n                var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos +';') + '</div>').appendTo(placeholder);\n                if (options.legend.backgroundOpacity != 0.0) {\n                    // put in the transparent background\n                    // separately to avoid blended labels and\n                    // label boxes\n                    var c = options.legend.backgroundColor;\n                    if (c == null) {\n                        c = options.grid.backgroundColor;\n                        if (c && typeof c == \"string\")\n                            c = $.color.parse(c);\n                        else\n                            c = $.color.extract(legend, 'background-color');\n                        c.a = 1;\n                        c = c.toString();\n                    }\n                    var div = legend.children();\n                    $('<div style=\"position:absolute;width:' + div.width() + 'px;height:' + div.height() + 'px;' + pos +'background-color:' + c + ';\"> </div>').prependTo(legend).css('opacity', options.legend.backgroundOpacity);\n                }\n            }\n        }\n\n\n        // interactive features\n\n        var highlights = [],\n            redrawTimeout = null;\n\n        // returns the data item the mouse is over, or null if none is found\n        function findNearbyItem(mouseX, mouseY, seriesFilter) {\n            var maxDistance = options.grid.mouseActiveRadius,\n                smallestDistance = maxDistance * maxDistance + 1,\n                item = null, foundPoint = false, i, j, ps;\n\n            for (i = series.length - 1; i >= 0; --i) {\n                if (!seriesFilter(series[i]))\n                    continue;\n\n                var s = series[i],\n                    axisx = s.xaxis,\n                    axisy = s.yaxis,\n                    points = s.datapoints.points,\n                    mx = axisx.c2p(mouseX), // precompute some stuff to make the loop faster\n                    my = axisy.c2p(mouseY),\n                    maxx = maxDistance / axisx.scale,\n                    maxy = maxDistance / axisy.scale;\n\n                ps = s.datapoints.pointsize;\n                // with inverse transforms, we can't use the maxx/maxy\n                // optimization, sadly\n                if (axisx.options.inverseTransform)\n                    maxx = Number.MAX_VALUE;\n                if (axisy.options.inverseTransform)\n                    maxy = Number.MAX_VALUE;\n\n                if (s.lines.show || s.points.show) {\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1];\n                        if (x == null)\n                            continue;\n\n                        // For points and lines, the cursor must be within a\n                        // certain distance to the data point\n                        if (x - mx > maxx || x - mx < -maxx ||\n                            y - my > maxy || y - my < -maxy)\n                            continue;\n\n                        // We have to calculate distances in pixels, not in\n                        // data units, because the scales of the axes may be different\n                        var dx = Math.abs(axisx.p2c(x) - mouseX),\n                            dy = Math.abs(axisy.p2c(y) - mouseY),\n                            dist = dx * dx + dy * dy; // we save the sqrt\n\n                        // use <= to ensure last point takes precedence\n                        // (last generally means on top of)\n                        if (dist < smallestDistance) {\n                            smallestDistance = dist;\n                            item = [i, j / ps];\n                        }\n                    }\n                }\n\n                if (s.bars.show && !item) { // no other point can be nearby\n\n                    var barLeft, barRight;\n\n                    switch (s.bars.align) {\n                        case \"left\":\n                            barLeft = 0;\n                            break;\n                        case \"right\":\n                            barLeft = -s.bars.barWidth;\n                            break;\n                        default:\n                            barLeft = -s.bars.barWidth / 2;\n                    }\n\n                    barRight = barLeft + s.bars.barWidth;\n\n                    for (j = 0; j < points.length; j += ps) {\n                        var x = points[j], y = points[j + 1], b = points[j + 2];\n                        if (x == null)\n                            continue;\n\n                        // for a bar graph, the cursor must be inside the bar\n                        if (series[i].bars.horizontal ?\n                            (mx <= Math.max(b, x) && mx >= Math.min(b, x) &&\n                             my >= y + barLeft && my <= y + barRight) :\n                            (mx >= x + barLeft && mx <= x + barRight &&\n                             my >= Math.min(b, y) && my <= Math.max(b, y)))\n                                item = [i, j / ps];\n                    }\n                }\n            }\n\n            if (item) {\n                i = item[0];\n                j = item[1];\n                ps = series[i].datapoints.pointsize;\n\n                return { datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n                         dataIndex: j,\n                         series: series[i],\n                         seriesIndex: i };\n            }\n\n            return null;\n        }\n\n        function onMouseMove(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return s[\"hoverable\"] != false; });\n        }\n\n        function onMouseLeave(e) {\n            if (options.grid.hoverable)\n                triggerClickHoverEvent(\"plothover\", e,\n                                       function (s) { return false; });\n        }\n\n        function onClick(e) {\n            triggerClickHoverEvent(\"plotclick\", e,\n                                   function (s) { return s[\"clickable\"] != false; });\n        }\n\n        // trigger click or hover event (they send the same parameters\n        // so we share their code)\n        function triggerClickHoverEvent(eventname, event, seriesFilter) {\n            var offset = eventHolder.offset(),\n                canvasX = event.pageX - offset.left - plotOffset.left,\n                canvasY = event.pageY - offset.top - plotOffset.top,\n            pos = canvasToAxisCoords({ left: canvasX, top: canvasY });\n\n            pos.pageX = event.pageX;\n            pos.pageY = event.pageY;\n\n            var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n\n            if (item) {\n                // fill in mouse pos for any listeners out there\n                item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n                item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10);\n            }\n\n            if (options.grid.autoHighlight) {\n                // clear auto-highlights\n                for (var i = 0; i < highlights.length; ++i) {\n                    var h = highlights[i];\n                    if (h.auto == eventname &&\n                        !(item && h.series == item.series &&\n                          h.point[0] == item.datapoint[0] &&\n                          h.point[1] == item.datapoint[1]))\n                        unhighlight(h.series, h.point);\n                }\n\n                if (item)\n                    highlight(item.series, item.datapoint, eventname);\n            }\n\n            placeholder.trigger(eventname, [ pos, item ]);\n        }\n\n        function triggerRedrawOverlay() {\n            var t = options.interaction.redrawOverlayInterval;\n            if (t == -1) {      // skip event queue\n                drawOverlay();\n                return;\n            }\n\n            if (!redrawTimeout)\n                redrawTimeout = setTimeout(drawOverlay, t);\n        }\n\n        function drawOverlay() {\n            redrawTimeout = null;\n\n            // draw highlights\n            octx.save();\n            overlay.clear();\n            octx.translate(plotOffset.left, plotOffset.top);\n\n            var i, hi;\n            for (i = 0; i < highlights.length; ++i) {\n                hi = highlights[i];\n\n                if (hi.series.bars.show)\n                    drawBarHighlight(hi.series, hi.point);\n                else\n                    drawPointHighlight(hi.series, hi.point);\n            }\n            octx.restore();\n\n            executeHooks(hooks.drawOverlay, [octx]);\n        }\n\n        function highlight(s, point, auto) {\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i == -1) {\n                highlights.push({ series: s, point: point, auto: auto });\n\n                triggerRedrawOverlay();\n            }\n            else if (!auto)\n                highlights[i].auto = false;\n        }\n\n        function unhighlight(s, point) {\n            if (s == null && point == null) {\n                highlights = [];\n                triggerRedrawOverlay();\n                return;\n            }\n\n            if (typeof s == \"number\")\n                s = series[s];\n\n            if (typeof point == \"number\") {\n                var ps = s.datapoints.pointsize;\n                point = s.datapoints.points.slice(ps * point, ps * (point + 1));\n            }\n\n            var i = indexOfHighlight(s, point);\n            if (i != -1) {\n                highlights.splice(i, 1);\n\n                triggerRedrawOverlay();\n            }\n        }\n\n        function indexOfHighlight(s, p) {\n            for (var i = 0; i < highlights.length; ++i) {\n                var h = highlights[i];\n                if (h.series == s && h.point[0] == p[0]\n                    && h.point[1] == p[1])\n                    return i;\n            }\n            return -1;\n        }\n\n        function drawPointHighlight(series, point) {\n            var x = point[0], y = point[1],\n                axisx = series.xaxis, axisy = series.yaxis,\n                highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString();\n\n            if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max)\n                return;\n\n            var pointRadius = series.points.radius + series.points.lineWidth / 2;\n            octx.lineWidth = pointRadius;\n            octx.strokeStyle = highlightColor;\n            var radius = 1.5 * pointRadius;\n            x = axisx.p2c(x);\n            y = axisy.p2c(y);\n\n            octx.beginPath();\n            if (series.points.symbol == \"circle\")\n                octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n            else\n                series.points.symbol(octx, x, y, radius, false);\n            octx.closePath();\n            octx.stroke();\n        }\n\n        function drawBarHighlight(series, point) {\n            var highlightColor = (typeof series.highlightColor === \"string\") ? series.highlightColor : $.color.parse(series.color).scale('a', 0.5).toString(),\n                fillStyle = highlightColor,\n                barLeft;\n\n            switch (series.bars.align) {\n                case \"left\":\n                    barLeft = 0;\n                    break;\n                case \"right\":\n                    barLeft = -series.bars.barWidth;\n                    break;\n                default:\n                    barLeft = -series.bars.barWidth / 2;\n            }\n\n            octx.lineWidth = series.bars.lineWidth;\n            octx.strokeStyle = highlightColor;\n\n            drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n                    function () { return fillStyle; }, series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth);\n        }\n\n        function getColorOrGradient(spec, bottom, top, defaultColor) {\n            if (typeof spec == \"string\")\n                return spec;\n            else {\n                // assume this is a gradient spec; IE currently only\n                // supports a simple vertical gradient properly, so that's\n                // what we support too\n                var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n\n                for (var i = 0, l = spec.colors.length; i < l; ++i) {\n                    var c = spec.colors[i];\n                    if (typeof c != \"string\") {\n                        var co = $.color.parse(defaultColor);\n                        if (c.brightness != null)\n                            co = co.scale('rgb', c.brightness);\n                        if (c.opacity != null)\n                            co.a *= c.opacity;\n                        c = co.toString();\n                    }\n                    gradient.addColorStop(i / (l - 1), c);\n                }\n\n                return gradient;\n            }\n        }\n    }\n\n    // Add the plot function to the top level of the jQuery object\n\n    $.plot = function(placeholder, data, options) {\n        //var t0 = new Date();\n        var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n        //(window.console ? console.log : alert)(\"time used (msecs): \" + ((new Date()).getTime() - t0.getTime()));\n        return plot;\n    };\n\n    $.plot.version = \"0.8.3\";\n\n    $.plot.plugins = [];\n\n    // Also add the plot function as a chainable property\n\n    $.fn.plot = function(data, options) {\n        return this.each(function() {\n            $.plot(this, data, options);\n        });\n    };\n\n    // round to nearby lower multiple of base\n    function floorInBase(n, base) {\n        return base * Math.floor(n / base);\n    }\n\n})(jQuery);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /nix/store/0cfiqvxmcpndhw8zx0yc286xz1zc0bjx-node-dependencies-ColEx-0.1.0/lib/node_modules/jquery-flot/jquery.flot.js\n// module id = 24\n// module chunks = 1","let colors =  {\n    hue: [\n        '#b5bae6',\n        '#d1abe6',\n        '#e6abd0',\n        '#e6bcb5',\n        '#dee2b5',\n        '#b5e2b5',\n        '#b5e2df'\n    ],\n    chroma: [\n        '#d7d6e6',\n        '#b5bbe6',\n        '#919fe6',\n        '#6d84e6',\n        '#4769e6',\n        '#1d4de6'\n    ],\n    value: [\n        '#b5bbe6',\n        '#9090b8',\n        '#6b6688',\n        '#443c56',\n        '#18121e'\n    ]\n};\n\ncolors.bodyBack = '#eee';\ncolors.bodyBackAlt = colors.value[0];\ncolors.inactive = colors.value[2];\ncolors.lightText = colors.value[3];\ncolors.bodyText = colors.value[4];\n\ncolors.noteBack = colors.hue[4];\ncolors.menu = colors.hue[5];\n\nexport default colors\n\n\n\n// WEBPACK FOOTER //\n// ./js/colors.wp.es.js","import jStat from 'jStat'\nimport plot from 'plot'\n\nvar interval = [-1, 1];\nvar burn_timeout_id;\nvar sample_timeout_id;\nvar plot_timeout_id;\n\nvar posterior_predictive_check = function(chain) {\n    var rand_int = function (min, max) {\n        return Math.floor(Math.random() * (max - min)) + min;\n    };\n\n    var n_post = 10;\n    var l = chain.length;\n    var preds = [];\n    for (var i = 0; i < n_post; i++) {\n        var params = chain[rand_int(0, l)];\n        preds.push(plot.sampleFunc(-1, 1, function(x) {\n            return generalized_beta(x, params[0], params[1], interval);\n        }));\n    }\n    return preds;\n};\nvar generalized_beta = function (x, a, b, interval) {\n    var min = interval[0];\n    var max = interval[1];\n    var normed = (x - min)/(max - min);\n    return jStat.beta.pdf(normed, a, b);\n};\nvar run_BEST = function (ys, n_samples_, n_burnin, progress_cb, final_cb) {\n    // Adaptive metropolis within Gibbs\n    var amwg = function (start_values, posterior) {\n        var n_params = start_values.length;\n        var batch_count = 0;\n        var batch_size = 50;\n        var chain = [];\n        var curr_state = start_values;\n        var log_sd = [];\n        var acceptance_count = [];\n        for (var i = 0; i < n_params; i++) {\n            log_sd[i] = 0;\n            acceptance_count[i] = 0;\n        }\n\n        var burn = function(n) {\n                   var temp_chain = chain.slice();\n                   n_samples(n);\n                   chain = temp_chain;\n        };\n        var derived_params = function(p) {\n            // mean scaled to our interval\n            return interval[0] + jStat.beta.mean(p[0], p[1]) * (interval[1] - interval[0]);\n        };\n        var next_sample = function () {\n            chain.push(curr_state.concat(derived_params(curr_state)));\n\n            for(var param_i = 0; param_i < n_params; param_i++) {\n                var param_prop = jStat.normal.sample(curr_state[param_i] , Math.exp(log_sd[param_i]));\n                var prop = curr_state.slice();\n                prop[param_i] = param_prop;\n                var accept_prob = Math.exp(posterior(prop) - posterior(curr_state));\n                if(accept_prob > Math.random()) {\n                    acceptance_count[param_i]++;\n                    curr_state = prop;\n                }\n            }\n\n            if(chain.length % batch_size === 0) {\n                batch_count++;\n                for(param_i = 0; param_i < n_params; param_i++) {\n                    if(acceptance_count[param_i] / batch_size > 0.44) {\n                        log_sd[param_i] += Math.min(0.01, 1/Math.sqrt(batch_count));\n                    } else if(acceptance_count[param_i] / batch_size < 0.44) {\n                        log_sd[param_i] -= Math.min(0.01, 1/Math.sqrt(batch_count));\n                    }\n                    acceptance_count[param_i] = 0;\n                }\n            }\n            return curr_state;\n        };\n        var n_samples = function (n) {\n            for(var i = 0; i < n - 1; i++) {\n                next_sample();\n            }\n            return next_sample();\n        };\n        var running_asynch = false;\n        var samples_left = n_samples_;\n        var n_samples_asynch = function (n, nbr_of_samples) {\n            samples_left = n;\n            if(n > 0) {\n                running_asynch = true;\n                n_samples(nbr_of_samples);\n                return setTimeout(function() {n_samples_asynch(n - nbr_of_samples, nbr_of_samples);}, 0);\n            } else {\n                running_asynch = false;\n                return null;\n            }\n        };\n        return {\n            chain: function() {return chain;},\n            running_asynch: function() {return running_asynch;},\n            burn: burn,\n            n_samples: n_samples, samples_left: function () {return samples_left;},\n            n_samples_asynch: n_samples_asynch\n        };\n    };\n\n    var make_BEST_posterior_func = function (data) {\n        return function(params) {\n            var alpha = params[0];\n            var beta = params[1];\n            var log_p = 0;\n            log_p += Math.log(jStat.exponential.pdf(alpha, 1));\n            log_p += Math.log(jStat.exponential.pdf(beta, 1));\n            for(var subj_i = 0, l = data.length; subj_i < l; subj_i++) {\n                log_p += Math.log(generalized_beta(data[subj_i], alpha, beta, interval));\n            }\n            return log_p;\n        };\n    };\n\n    var burn_asynch = function(n) {\n        sampler.burn(500);\n        if(n > 0) {\n            var fracDone = 1 - 500 * n / n_burnin;\n            progress_cb(0.45 * fracDone);\n            burn_timeout_id = setTimeout(function() {burn_asynch(n - 1);}, 0);\n        } else {\n            sample_timeout_id = sampler.n_samples_asynch(n_samples_, 50);\n            plot_asynch();\n        }\n    };\n    var plot_asynch = function() {\n        if(sampler.running_asynch()) {\n            var fracDone =  1 - sampler.samples_left() / n_samples_;\n            progress_cb(0.45 + fracDone * 0.45);\n            plot_timeout_id = setTimeout(plot_asynch, 0);\n        } else {\n            final_cb(sampler.chain());\n        }\n    };\n\n    clearTimeout(burn_timeout_id);\n    clearTimeout(sample_timeout_id);\n    clearTimeout(plot_timeout_id);\n\n    var sampler = amwg([1, 1], make_BEST_posterior_func(ys)) ;\n    burn_asynch(Math.ceil(n_burnin /  500));\n};\n\nexport default {\n        posterior_predictive_check: posterior_predictive_check,\n        run_BEST: run_BEST\n    };\n\n\n\n// WEBPACK FOOTER //\n// ./js/mcmc.wp.es.js","(function (window, factory) {\n    if (typeof exports === 'object') {\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else {\n        window.jStat = factory();\n    }\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(arg) {\n  return typeof arg === 'number' && arg === arg;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  var i;\n\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (var i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function(i) {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (var i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (var i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, Math.random);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var issymmetric = true;\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      var colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      var rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    var rowSlice = rcSlice.row || {};\n    var colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    var nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    var ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  var ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  var nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = new Function(\n        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  return Math.pow(jStat.product(arr), 1 / arr.length);\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (var i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var arrlen = arr.length;\n  var sorted = arr.slice().sort(ascNum);\n  var ranks = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    var first = sorted.indexOf(arr[i]);\n    var last = sorted.lastIndexOf(arr[i]);\n    if (first === last) {\n      var val = first;\n    } else {\n      var val = (first + last) / 2;\n    }\n    ranks[i] = val + 1;\n  }\n  return ranks;\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (var i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (var i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Returns the k-th percentile of values in a range, where k is in the\n// range 0..1, exclusive.\njStat.percentile = function percentile(arr, k) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length - 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n\n  if (index + 1 < _arr.length) {\n    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;\n  } else {\n    return _arr[index];\n  }\n}\n\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (var i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, bins) {\n  var first = jStat.min(arr);\n  var binCnt = bins || 4;\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (var i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (var i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (var i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        var callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        var callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res, sum, ysq;\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (var i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (var i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an, endval;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q, mat;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = Math.random();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function(a, b, c) {\n      if (!(this instanceof arguments.callee))\n        return new arguments.callee(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local, scale) {\n    return local;\n  },\n\n  mode: function mode(local, scale) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(rate) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(Math.random());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(alpha, beta) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu, sigma) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean, std) {\n    return mean;\n  },\n\n  median: function median(mean, std) {\n    return mean;\n  },\n\n  mode: function (mean, std) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale, shape) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(dof) {\n    return 0;\n  },\n\n  mode: function mode(dof) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var binomarr = [],\n    k = 0;\n    if (x < 0) {\n      return 0;\n    }\n    if (x < n) {\n      for (; k <= x; k++) {\n        binomarr[ k ] = jStat.binomial.pdf(k, n, p);\n      }\n      return jStat.sum(binomarr);\n    }\n    return 1;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sample: function sample(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= Math.random();\n    } while (p > L);\n    return k - 1;\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = Math.random();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(a, b) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu, b) {\n    return mu;\n  },\n\n  median: function(mu, b) {\n    return mu;\n  },\n\n  mode: function(mu, b) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = Math.random() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    for (var i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (var i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    var alen = a.length,\n    alend = alen * 2,\n    vals = new Array(alend),\n    rowshift = alen - 1,\n    colshift = alend - 1,\n    mrow = rowshift - alen + 1,\n    mcol = colshift,\n    i = 0,\n    result = 0,\n    j;\n    // check for special 2x2 case\n    if (alen === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n    for (; i < alend; i++) {\n      vals[i] = 1;\n    }\n    for (var i = 0; i < alen; i++) {\n      for (j = 0; j < alen; j++) {\n        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];\n        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];\n        mrow++;\n        mcol--;\n      }\n      mrow = --rowshift - alen + 1;\n      mcol = --colshift;\n    }\n    for (var i = 0; i < alen; i++) {\n      result += vals[i];\n    }\n    for (; i < alend; i++) {\n      result -= vals[i];\n    }\n    return result;\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(var i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (var i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b),\n    h = m.length,\n    w = m[0].length;\n    var c = 0;\n    // find max pivot\n    for (var y = 0; y < h; y++) {\n      var maxrow = y;\n      for (var y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (var y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (var x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (var y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (var y2 = 0; y2 < y; y2++) {\n        for (var x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (var x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[i][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function get_Q1(x) {\n      var size = x.length;\n      var norm_x = jStat.norm(x, 2);\n      var e1 = jStat.zeros(1, size)[0];\n      e1[0] = 1;\n      var u = jStat.add(jStat.multiply(jStat.multiply(e1, norm_x), -1), x);\n      var norm_u = jStat.norm(u, 2);\n      var v = jStat.divide(u, norm_u);\n      var Q = jStat.subtract(jStat.identity(size),\n                             jStat.multiply(jStat.outer(v, v), 2));\n      return Q;\n    }\n\n    function qr(A) {\n      var size = A[0].length;\n      var QList = [];\n      jStat.arange(size).forEach(function(i) {\n        var x = jStat.slice(A, { row: { start: i }, col: i });\n        var Q = get_Q1(x);\n        var Qn = jStat.identity(A.length);\n        Qn = jStat.sliceAssign(Qn, { row: { start: i }, col: { start: i }}, Q);\n        A = jStat.multiply(Qn, A);\n        QList.push(Qn);\n      });\n      var Q = QList.reduce(function(x, y){ return jStat.multiply(x,y) });\n      var R = A;\n      return [Q, R];\n    }\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      x = jStat.copy(x);\n      r = jStat.zeros(p, p);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function(A, b) {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n\t  var Q2 = jStat.transpose(Q1);\n\n\t  if(Q2[0].length === undefined){\n\t\t  Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n\t  if(x.length === undefined){\n\t\t  x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n\t  }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var count = 0;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      count++;\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (var i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (var i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (var i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I, d;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var n = X.length,\n    h_min = Math.abs(x - X[pos(X, x) + 1]),\n    i = 0,\n    g = [],\n    h1 = [],\n    y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (var i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (var i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var flag = false;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (var i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (var i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (var i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (var i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (var i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // 2 sample case\n    if (args.length === 2) {\n      return jStat.variance(args[0]) / jStat.variance(args[1]);\n    }\n    // Builds sample array\n    sample = new Array();\n    for (var i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (var i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (var i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (var i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n\n  function sub_regress(endog, exog) {\n    return ols(endog, exog);\n  }\n\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /nix/store/0cfiqvxmcpndhw8zx0yc286xz1zc0bjx-node-dependencies-ColEx-0.1.0/lib/node_modules/jStat/dist/jstat.js\n// module id = 3\n// module chunks = 1"],"sourceRoot":""}